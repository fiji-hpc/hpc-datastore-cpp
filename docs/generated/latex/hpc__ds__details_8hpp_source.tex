\hypertarget{hpc__ds__details_8hpp_source}{}\doxysection{hpc\+\_\+ds\+\_\+details.\+hpp}
\label{hpc__ds__details_8hpp_source}\index{/home/somik/CBIA/hpc-\/datastore-\/cpp/src/hpc\_ds\_details.hpp@{/home/somik/CBIA/hpc-\/datastore-\/cpp/src/hpc\_ds\_details.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#include "{}hpc\_ds\_structs.hpp"{}}}
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <Poco/JSON/Object.h>}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#include <Poco/JSON/Parser.h>}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <Poco/Net/HTTPClientSession.h>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <Poco/Net/HTTPMessage.h>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <Poco/Net/HTTPRequest.h>}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include <Poco/Net/HTTPResponse.h>}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include <Poco/URI.h>}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include <i3d/image3d.h>}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <i3d/vector3d.h>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <optional>}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <source\_location>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <span>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{17 \textcolor{comment}{/* ==================== DETAILS HEADERS ============================ */}}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{keyword}{namespace }datastore \{}
\DoxyCodeLine{20 \textcolor{keyword}{namespace }details \{}
\DoxyCodeLine{21 \textcolor{comment}{/* Definition of compile settings */}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{preprocessor}{\#ifdef DATASTORE\_NDEBUG}}
\DoxyCodeLine{24 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_DEBUG\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#ifdef NDEBUG}}
\DoxyCodeLine{27 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_DEBUG\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{29 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_DEBUG\_ = \textcolor{keyword}{true};}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{preprocessor}{\#ifdef DATASTORE\_NLOG}}
\DoxyCodeLine{34 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_LOG\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{36 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_LOG\_ = \_DEBUG\_;}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{preprocessor}{\#ifdef DATASTORE\_NINFO}}
\DoxyCodeLine{40 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_INFO\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{42 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_INFO\_ = \_LOG\_;}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{preprocessor}{\#ifdef DATASTORE\_NWARNING}}
\DoxyCodeLine{46 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_WARNING\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{48 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_WARNING\_ = \_LOG\_;}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 \textcolor{preprocessor}{\#ifdef DATASTORE\_NERROR}}
\DoxyCodeLine{52 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_ERROR\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{54 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_ERROR\_ = \_LOG\_;}
\DoxyCodeLine{55 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{56 }
\DoxyCodeLine{65 \textcolor{keyword}{inline} std::string}
\DoxyCodeLine{66 get\_dataset\_url(\textcolor{keyword}{const} std::string\& ip, \textcolor{keywordtype}{int} port, \textcolor{keyword}{const} std::string\& uuid);}
\DoxyCodeLine{67 }
\DoxyCodeLine{74 \textcolor{keyword}{inline} DatasetProperties get\_dataset\_properties(\textcolor{keyword}{const} std::string\& dataset\_url);}
\DoxyCodeLine{75 }
\DoxyCodeLine{84 \textcolor{keyword}{inline} i3d::Vector3d<int> get\_block\_dimensions(\textcolor{keyword}{const} DatasetProperties\& props,}
\DoxyCodeLine{85                                                i3d::Vector3d<int> resolution);}
\DoxyCodeLine{86 }
\DoxyCodeLine{98 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} check\_block\_coords(\textcolor{keyword}{const} std::vector<i3d::Vector3d<int>>\& coords,}
\DoxyCodeLine{99                                i3d::Vector3d<int> img\_dim,}
\DoxyCodeLine{100                                i3d::Vector3d<int> block\_dim);}
\DoxyCodeLine{101 }
\DoxyCodeLine{116 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{117 \textcolor{keywordtype}{bool} check\_offset\_coords(\textcolor{keyword}{const} std::vector<i3d::Vector3d<int>>\& offsets,}
\DoxyCodeLine{118                          \textcolor{keyword}{const} std::vector<i3d::Vector3d<int>>\& coords,}
\DoxyCodeLine{119                          \textcolor{keyword}{const} i3d::Image3d<T>\& img,}
\DoxyCodeLine{120                          i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{121                          i3d::Vector3d<int> img\_dim);}
\DoxyCodeLine{122 \textcolor{keyword}{namespace }data\_manip \{}
\DoxyCodeLine{123 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} get\_block\_data\_size(i3d::Vector3d<int> block\_size,}
\DoxyCodeLine{124                                \textcolor{keyword}{const} std::string\& voxel\_type);}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{keyword}{inline} i3d::Vector3d<int> get\_block\_size(i3d::Vector3d<int> coord,}
\DoxyCodeLine{127                                          i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{128                                          i3d::Vector3d<int> img\_dim);}
\DoxyCodeLine{129 }
\DoxyCodeLine{130 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} get\_linear\_index(i3d::Vector3d<int> coord,}
\DoxyCodeLine{131                             i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{132                             \textcolor{keyword}{const} std::string\& voxel\_type);}
\DoxyCodeLine{133 }
\DoxyCodeLine{134 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{135 T get\_elem\_at(std::span<const char> data,}
\DoxyCodeLine{136               \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{137               \textcolor{keywordtype}{int} index);}
\DoxyCodeLine{138 }
\DoxyCodeLine{139 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{140 T get\_elem\_at(std::span<const char> data,}
\DoxyCodeLine{141               \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{142               i3d::Vector3d<int> coord,}
\DoxyCodeLine{143               i3d::Vector3d<int> block\_dim);}
\DoxyCodeLine{144 }
\DoxyCodeLine{145 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{146 \textcolor{keywordtype}{void} set\_elem\_at(std::span<char> data,}
\DoxyCodeLine{147                  \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{148                  \textcolor{keywordtype}{int} index,}
\DoxyCodeLine{149                  T elem);}
\DoxyCodeLine{150 }
\DoxyCodeLine{151 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{152 \textcolor{keywordtype}{void} set\_elem\_at(std::span<char> data,}
\DoxyCodeLine{153                  \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{154                  i3d::Vector3d<int> coord,}
\DoxyCodeLine{155                  i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{156                  T elem);}
\DoxyCodeLine{157 }
\DoxyCodeLine{167 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{168 \textcolor{keywordtype}{void} read\_data(std::span<const char> data,}
\DoxyCodeLine{169                \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{170                i3d::Image3d<T>\& dest,}
\DoxyCodeLine{171                i3d::Vector3d<int> offset);}
\DoxyCodeLine{172 }
\DoxyCodeLine{183 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{184 \textcolor{keywordtype}{void} write\_data(\textcolor{keyword}{const} i3d::Image3d<T>\& src,}
\DoxyCodeLine{185                 i3d::Vector3d<int> offset,}
\DoxyCodeLine{186                 std::span<char> data,}
\DoxyCodeLine{187                 \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{188                 i3d::Vector3d<int> block\_size);}
\DoxyCodeLine{189 \} \textcolor{comment}{// namespace data\_manip}}
\DoxyCodeLine{190 }
\DoxyCodeLine{191 \textcolor{keyword}{namespace }log \{}
\DoxyCodeLine{192 }
\DoxyCodeLine{203 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \_log(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{204                  \textcolor{keyword}{const} std::string\& type,}
\DoxyCodeLine{205                  \textcolor{keyword}{const} std::source\_location\& location);}
\DoxyCodeLine{206 }
\DoxyCodeLine{213 \textcolor{keyword}{inline} \textcolor{keywordtype}{void}}
\DoxyCodeLine{214 info(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{215      \textcolor{keyword}{const} std::source\_location\& location = std::source\_location::current());}
\DoxyCodeLine{216 }
\DoxyCodeLine{223 \textcolor{keyword}{inline} \textcolor{keywordtype}{void}}
\DoxyCodeLine{224 warning(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{225         \textcolor{keyword}{const} std::source\_location\& location = std::source\_location::current());}
\DoxyCodeLine{226 }
\DoxyCodeLine{233 \textcolor{keyword}{inline} \textcolor{keywordtype}{void}}
\DoxyCodeLine{234 error(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{235       \textcolor{keyword}{const} std::source\_location\& location = std::source\_location::current());}
\DoxyCodeLine{236 \} \textcolor{comment}{// namespace log}}
\DoxyCodeLine{237 }
\DoxyCodeLine{238 \textcolor{comment}{/* Helpers to parse Dataset Properties from JSON */}}
\DoxyCodeLine{239 \textcolor{keyword}{namespace }props\_parser \{}
\DoxyCodeLine{240 \textcolor{keyword}{using namespace }Poco::JSON;}
\DoxyCodeLine{241 }
\DoxyCodeLine{242 \textcolor{keyword}{template} <cnpts::Basic T>}
\DoxyCodeLine{243 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{244 }
\DoxyCodeLine{245 \textcolor{keyword}{template} <cnpts::Vector3d T>}
\DoxyCodeLine{246 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{247 }
\DoxyCodeLine{248 \textcolor{keyword}{template} <cnpts::Vector T>}
\DoxyCodeLine{249 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{250 }
\DoxyCodeLine{251 \textcolor{keyword}{template} <cnpts::ResolutionUnit T>}
\DoxyCodeLine{252 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{253 }
\DoxyCodeLine{254 \textcolor{keyword}{template} <cnpts::Optional T>}
\DoxyCodeLine{255 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{256 }
\DoxyCodeLine{257 \textcolor{keyword}{inline} std::vector<std::map<std::string, i3d::Vector3d<int>>>}
\DoxyCodeLine{258 get\_resolution\_levels(Object::Ptr root);}
\DoxyCodeLine{259 }
\DoxyCodeLine{260 \} \textcolor{comment}{// namespace props\_parser}}
\DoxyCodeLine{261 }
\DoxyCodeLine{262 \textcolor{comment}{/* Helpers providing requests functionality */}}
\DoxyCodeLine{263 \textcolor{keyword}{namespace }requests \{}
\DoxyCodeLine{264 \textcolor{keyword}{inline} std::string session\_url\_request(\textcolor{keyword}{const} std::string\& ds\_url,}
\DoxyCodeLine{265                                        i3d::Vector3d<int> resolution,}
\DoxyCodeLine{266                                        \textcolor{keyword}{const} std::string\& version);}
\DoxyCodeLine{267 }
\DoxyCodeLine{268 \textcolor{keyword}{inline} std::pair<std::vector<char>, Poco::Net::HTTPResponse>}
\DoxyCodeLine{269 make\_request(\textcolor{keyword}{const} std::string\& url,}
\DoxyCodeLine{270              \textcolor{keyword}{const} std::string\& type = Poco::Net::HTTPRequest::HTTP\_GET,}
\DoxyCodeLine{271              \textcolor{keyword}{const} std::vector<char>\& data = \{\},}
\DoxyCodeLine{272              \textcolor{keyword}{const} std::map<std::string, std::string>\& headers = \{\});}
\DoxyCodeLine{273 \} \textcolor{comment}{// namespace requests}}
\DoxyCodeLine{274 \} \textcolor{comment}{// namespace details}}
\DoxyCodeLine{275 \} \textcolor{comment}{// namespace datastore}}
\DoxyCodeLine{276 }
\DoxyCodeLine{277 \textcolor{comment}{/* ================= IMPLEMENTATION FOLLOWS ======================== */}}
\DoxyCodeLine{278 \textcolor{keyword}{namespace }datastore \{}
\DoxyCodeLine{279 \textcolor{keyword}{namespace }details \{}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 \textcolor{comment}{/* inline */} std::string}
\DoxyCodeLine{282 get\_dataset\_url(\textcolor{keyword}{const} std::string\& ip, \textcolor{keywordtype}{int} port, \textcolor{keyword}{const} std::string\& uuid) \{}
\DoxyCodeLine{283     std::string out;}
\DoxyCodeLine{284     \textcolor{keywordflow}{if} (!ip.starts\_with(\textcolor{stringliteral}{"{}http://"{}}))}
\DoxyCodeLine{285         out = \textcolor{stringliteral}{"{}https://"{}};}
\DoxyCodeLine{286     \textcolor{keywordflow}{return} out + fmt::format(\textcolor{stringliteral}{"{}\{\}:\{\}/datasets/\{\}"{}}, ip, port, uuid);}
\DoxyCodeLine{287 \}}
\DoxyCodeLine{288 }
\DoxyCodeLine{289 \textcolor{keyword}{inline} DatasetProperties}
\DoxyCodeLine{290 get\_dataset\_properties(\textcolor{keyword}{const} std::string\& dataset\_url) \{}
\DoxyCodeLine{291     \textcolor{keyword}{using namespace }Poco::JSON;}
\DoxyCodeLine{292 }
\DoxyCodeLine{293     \textcolor{comment}{/* Fetch JSON from server */}}
\DoxyCodeLine{294     \textcolor{keyword}{auto} [data, response] = requests::make\_request(dataset\_url);}
\DoxyCodeLine{295     std::string json\_str(data.begin(), data.end());}
\DoxyCodeLine{296 }
\DoxyCodeLine{297     \textcolor{keywordtype}{int} res\_code = response.getStatus();}
\DoxyCodeLine{298     \textcolor{keywordflow}{if} (res\_code != 200)}
\DoxyCodeLine{299         log::warning(fmt::format(}
\DoxyCodeLine{300             \textcolor{stringliteral}{"{}Request ended with code: \{\}. json may not be valid"{}}, res\_code));}
\DoxyCodeLine{301 }
\DoxyCodeLine{302     log::info(\textcolor{stringliteral}{"{}Parsing dataset properties from JSON string"{}});}
\DoxyCodeLine{303     Parser parser;}
\DoxyCodeLine{304     Poco::Dynamic::Var result = parser.parse(json\_str);}
\DoxyCodeLine{305 }
\DoxyCodeLine{306     DatasetProperties props;}
\DoxyCodeLine{307     \textcolor{keyword}{auto} root = result.extract<Object::Ptr>();}
\DoxyCodeLine{308 }
\DoxyCodeLine{309     \textcolor{keyword}{using namespace }props\_parser;}
\DoxyCodeLine{310 }
\DoxyCodeLine{311     \textcolor{comment}{/* Parse elements from JSON */}}
\DoxyCodeLine{312 }
\DoxyCodeLine{313     props.uuid = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}uuid"{}});}
\DoxyCodeLine{314     props.voxel\_type = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}voxelType"{}});}
\DoxyCodeLine{315     props.dimensions = get\_elem<i3d::Vector3d<int>>(root, \textcolor{stringliteral}{"{}dimensions"{}});}
\DoxyCodeLine{316     props.channels = get\_elem<int>(root, \textcolor{stringliteral}{"{}channels"{}});}
\DoxyCodeLine{317     props.angles = get\_elem<int>(root, \textcolor{stringliteral}{"{}angles"{}});}
\DoxyCodeLine{318     props.transformations =}
\DoxyCodeLine{319         get\_elem<std::optional<std::string>>(root, \textcolor{stringliteral}{"{}transformations"{}});}
\DoxyCodeLine{320     props.voxel\_unit = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}voxelUnit"{}});}
\DoxyCodeLine{321     props.voxel\_resolution =}
\DoxyCodeLine{322         get\_elem<std::optional<i3d::Vector3d<double>>>(root, \textcolor{stringliteral}{"{}voxelResolution"{}});}
\DoxyCodeLine{323     props.timepoint\_resolution =}
\DoxyCodeLine{324         get\_elem<std::optional<ResolutionUnit>>(root, \textcolor{stringliteral}{"{}timepointResolution"{}});}
\DoxyCodeLine{325     props.channel\_resolution =}
\DoxyCodeLine{326         get\_elem<std::optional<ResolutionUnit>>(root, \textcolor{stringliteral}{"{}channelResolution"{}});}
\DoxyCodeLine{327     props.angle\_resolution =}
\DoxyCodeLine{328         get\_elem<std::optional<ResolutionUnit>>(root, \textcolor{stringliteral}{"{}angleResolution"{}});}
\DoxyCodeLine{329     props.compression = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}compression"{}});}
\DoxyCodeLine{330     props.resolution\_levels = get\_resolution\_levels(root);}
\DoxyCodeLine{331     props.versions = get\_elem<std::vector<int>>(root, \textcolor{stringliteral}{"{}versions"{}});}
\DoxyCodeLine{332     props.label = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}label"{}});}
\DoxyCodeLine{333     props.view\_registrations =}
\DoxyCodeLine{334         get\_elem<std::optional<std::string>>(root, \textcolor{stringliteral}{"{}viewRegistrations"{}});}
\DoxyCodeLine{335     props.timepoint\_ids = get\_elem<std::vector<int>>(root, \textcolor{stringliteral}{"{}timepointIds"{}});}
\DoxyCodeLine{336 }
\DoxyCodeLine{337     log::info(\textcolor{stringliteral}{"{}Parsing has finished"{}});}
\DoxyCodeLine{338     \textcolor{keywordflow}{return} props;}
\DoxyCodeLine{339 \}}
\DoxyCodeLine{340 }
\DoxyCodeLine{341 \textcolor{comment}{/* inline */} i3d::Vector3d<int>}
\DoxyCodeLine{342 get\_block\_dimensions(\textcolor{keyword}{const} DatasetProperties\& props,}
\DoxyCodeLine{343                      i3d::Vector3d<int> resolution) \{}
\DoxyCodeLine{344     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& res\_level : props.resolution\_levels)}
\DoxyCodeLine{345         \textcolor{keywordflow}{if} (res\_level.at(\textcolor{stringliteral}{"{}resolutions"{}}) == resolution)}
\DoxyCodeLine{346             \textcolor{keywordflow}{return} res\_level.at(\textcolor{stringliteral}{"{}blockDimensions"{}});}
\DoxyCodeLine{347 }
\DoxyCodeLine{348     log::error(fmt::format(\textcolor{stringliteral}{"{}Dimensions for resolution \{\} not found"{}},}
\DoxyCodeLine{349                            to\_string(resolution)));}
\DoxyCodeLine{350     \textcolor{keywordflow}{return} \{-\/1, -\/1, -\/1\};}
\DoxyCodeLine{351 \}}
\DoxyCodeLine{352 }
\DoxyCodeLine{353 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{bool}}
\DoxyCodeLine{354 check\_block\_coords(\textcolor{keyword}{const} std::vector<i3d::Vector3d<int>>\& coords,}
\DoxyCodeLine{355                    i3d::Vector3d<int> img\_dim,}
\DoxyCodeLine{356                    i3d::Vector3d<int> block\_dim) \{}
\DoxyCodeLine{357     \textcolor{comment}{/* Act as NOOP if not in debug */}}
\DoxyCodeLine{358     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_DEBUG\_)}
\DoxyCodeLine{359         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{360 }
\DoxyCodeLine{361     log::info(\textcolor{stringliteral}{"{}Checking validity of given block coordinates"{}});}
\DoxyCodeLine{362 }
\DoxyCodeLine{363     \textcolor{keywordflow}{for} (i3d::Vector3d<int> coord : coords)}
\DoxyCodeLine{364         \textcolor{keywordflow}{if} (data\_manip::get\_block\_size(coord, block\_dim, img\_dim) ==}
\DoxyCodeLine{365             i3d::Vector3d(0, 0, 0)) \{}
\DoxyCodeLine{366             log::error(fmt::format(\textcolor{stringliteral}{"{}Block coordinate \{\} is out of valid range"{}},}
\DoxyCodeLine{367                                    to\_string(coord)));}
\DoxyCodeLine{368 }
\DoxyCodeLine{369             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{370         \}}
\DoxyCodeLine{371     log::info(\textcolor{stringliteral}{"{}Check successfullly finished"{}});}
\DoxyCodeLine{372     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{373 \}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{376 \textcolor{keywordtype}{bool} check\_offset\_coords(\textcolor{keyword}{const} std::vector<i3d::Vector3d<int>>\& offsets,}
\DoxyCodeLine{377                          \textcolor{keyword}{const} std::vector<i3d::Vector3d<int>>\& coords,}
\DoxyCodeLine{378                          \textcolor{keyword}{const} i3d::Image3d<T>\& img,}
\DoxyCodeLine{379                          i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{380                          i3d::Vector3d<int> img\_dim) \{}
\DoxyCodeLine{381     \textcolor{comment}{/* Act as NOOP if not in debug */}}
\DoxyCodeLine{382     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_DEBUG\_)}
\DoxyCodeLine{383         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{384 }
\DoxyCodeLine{385     \textcolor{keywordflow}{if} (offsets.size() != coords.size())}
\DoxyCodeLine{386         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{387 }
\DoxyCodeLine{388     log::info(\textcolor{stringliteral}{"{}Checking validity of given offset coordinates"{}});}
\DoxyCodeLine{389 }
\DoxyCodeLine{390     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < coords.size(); ++i) \{}
\DoxyCodeLine{391         \textcolor{keyword}{auto}\& coord = coords[i];}
\DoxyCodeLine{392         \textcolor{keyword}{auto}\& offset = offsets[i];}
\DoxyCodeLine{393 }
\DoxyCodeLine{394         i3d::Vector3d<int> block\_size =}
\DoxyCodeLine{395             data\_manip::get\_block\_size(coord, block\_dim, img\_dim);}
\DoxyCodeLine{396         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; ++i)}
\DoxyCodeLine{397             \textcolor{keywordflow}{if} (!(0 <= coord[i] \&\&}
\DoxyCodeLine{398                   std::size\_t(offset[i] + block\_size[i]) <= img.GetSize()[i])) \{}
\DoxyCodeLine{399                 log::error(}
\DoxyCodeLine{400                     fmt::format(\textcolor{stringliteral}{"{}Offset coordinate \{\} is out of valid range"{}},}
\DoxyCodeLine{401                                 to\_string(coord)));}
\DoxyCodeLine{402 }
\DoxyCodeLine{403                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{404             \}}
\DoxyCodeLine{405     \}}
\DoxyCodeLine{406     log::info(\textcolor{stringliteral}{"{}Check successfullly finished"{}});}
\DoxyCodeLine{407     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{408 \}}
\DoxyCodeLine{409 }
\DoxyCodeLine{410 \textcolor{keyword}{namespace }data\_manip \{}
\DoxyCodeLine{411 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{int} get\_block\_data\_size(i3d::Vector3d<int> block\_size,}
\DoxyCodeLine{412                                      \textcolor{keyword}{const} std::string\& voxel\_type) \{}
\DoxyCodeLine{413 }
\DoxyCodeLine{414     \textcolor{keywordtype}{int} elem\_size = type\_byte\_size.at(voxel\_type);}
\DoxyCodeLine{415     \textcolor{keywordflow}{return} block\_size.x * block\_size.y * block\_size.z * elem\_size + 12;}
\DoxyCodeLine{416 \}}
\DoxyCodeLine{417 }
\DoxyCodeLine{418 \textcolor{comment}{/* inline */} i3d::Vector3d<int> get\_block\_size(i3d::Vector3d<int> coord,}
\DoxyCodeLine{419                                                i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{420                                                i3d::Vector3d<int> img\_dim) \{}
\DoxyCodeLine{421     i3d::Vector3d<int> start = (coord * block\_dim);}
\DoxyCodeLine{422     i3d::Vector3d<int> end = (coord + 1) * block\_dim;}
\DoxyCodeLine{423 }
\DoxyCodeLine{424     i3d::Vector3d<int> out;}
\DoxyCodeLine{425     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; ++i) \{}
\DoxyCodeLine{426         out[i] =}
\DoxyCodeLine{427             std::max(0, std::min(img\_dim[i], end[i]) -\/ std::max(start[i], 0));}
\DoxyCodeLine{428     \}}
\DoxyCodeLine{429     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{430 \}}
\DoxyCodeLine{431 }
\DoxyCodeLine{432 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{int} get\_linear\_index(i3d::Vector3d<int> coord,}
\DoxyCodeLine{433                                   i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{434                                   \textcolor{keyword}{const} std::string\& voxel\_type) \{}
\DoxyCodeLine{435     \textcolor{keywordtype}{int} elem\_size = type\_byte\_size.at(voxel\_type);}
\DoxyCodeLine{436 }
\DoxyCodeLine{437     \textcolor{keywordflow}{return} 12 +                                   \textcolor{comment}{// header\_offset}}
\DoxyCodeLine{438            (coord.z * block\_dim.x * block\_dim.y + \textcolor{comment}{// Main axis}}
\DoxyCodeLine{439             coord.y * block\_dim.x +               \textcolor{comment}{// secondary axis}}
\DoxyCodeLine{440             coord.x) *                            \textcolor{comment}{// last axis}}
\DoxyCodeLine{441                elem\_size;                         \textcolor{comment}{// byte size}}
\DoxyCodeLine{442 \}}
\DoxyCodeLine{443 }
\DoxyCodeLine{444 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{445 T get\_elem\_at(std::span<const char> data,}
\DoxyCodeLine{446               \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{447               \textcolor{keywordtype}{int} index) \{}
\DoxyCodeLine{448     \textcolor{keywordtype}{int} elem\_size = type\_byte\_size.at(voxel\_type);}
\DoxyCodeLine{449 }
\DoxyCodeLine{450     std::array<char, \textcolor{keyword}{sizeof}(T)> buffer\{\};}
\DoxyCodeLine{451     std::copy\_n(data.begin() + index,      \textcolor{comment}{// source start}}
\DoxyCodeLine{452                 elem\_size,                 \textcolor{comment}{// count}}
\DoxyCodeLine{453                 buffer.end() -\/ elem\_size); \textcolor{comment}{// dest start}}
\DoxyCodeLine{454 }
\DoxyCodeLine{455     std::ranges::reverse(buffer);}
\DoxyCodeLine{456 }
\DoxyCodeLine{457     \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}(\&buffer[0]);}
\DoxyCodeLine{458 \}}
\DoxyCodeLine{459 }
\DoxyCodeLine{460 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{461 T get\_elem\_at(std::span<const char> data,}
\DoxyCodeLine{462               \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{463               i3d::Vector3d<int> coord,}
\DoxyCodeLine{464               i3d::Vector3d<int> block\_dim) \{}
\DoxyCodeLine{465 }
\DoxyCodeLine{466     \textcolor{keywordtype}{int} index = get\_linear\_index(coord, block\_dim, voxel\_type);}
\DoxyCodeLine{467     \textcolor{keywordflow}{return} get\_elem\_at<T>(data, voxel\_type, index);}
\DoxyCodeLine{468 \}}
\DoxyCodeLine{469 }
\DoxyCodeLine{470 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{471 \textcolor{keywordtype}{void} set\_elem\_at(std::span<char> data,}
\DoxyCodeLine{472                  \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{473                  \textcolor{keywordtype}{int} index,}
\DoxyCodeLine{474                  T elem) \{}
\DoxyCodeLine{475     \textcolor{keywordtype}{int} elem\_size = type\_byte\_size.at(voxel\_type);}
\DoxyCodeLine{476 }
\DoxyCodeLine{477     \textcolor{keyword}{auto} buffer = *\textcolor{keyword}{reinterpret\_cast<}std::array<\textcolor{keywordtype}{char}, sizeof(T)\textcolor{keyword}{>}*>(\&elem);}
\DoxyCodeLine{478     std::ranges::reverse(buffer);}
\DoxyCodeLine{479 }
\DoxyCodeLine{480     std::copy\_n(buffer.end() -\/ elem\_size, \textcolor{comment}{// source start}}
\DoxyCodeLine{481                 elem\_size,                \textcolor{comment}{// count}}
\DoxyCodeLine{482                 data.begin() + index);    \textcolor{comment}{// dest start}}
\DoxyCodeLine{483 \}}
\DoxyCodeLine{484 }
\DoxyCodeLine{485 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{486 \textcolor{keywordtype}{void} set\_elem\_at(std::span<char> data,}
\DoxyCodeLine{487                  \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{488                  i3d::Vector3d<int> coord,}
\DoxyCodeLine{489                  i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{490                  T elem) \{}
\DoxyCodeLine{491     \textcolor{keywordtype}{int} index = get\_linear\_index(coord, block\_dim, voxel\_type);}
\DoxyCodeLine{492     set\_elem\_at(data, voxel\_type, index, elem);}
\DoxyCodeLine{493 \}}
\DoxyCodeLine{494 }
\DoxyCodeLine{495 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{496 \textcolor{keywordtype}{void} read\_data(std::span<const char> data,}
\DoxyCodeLine{497                \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{498                i3d::Image3d<T>\& dest,}
\DoxyCodeLine{499                i3d::Vector3d<int> offset) \{}
\DoxyCodeLine{500     i3d::Vector3d<int> block\_dim;}
\DoxyCodeLine{501     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; ++i)}
\DoxyCodeLine{502         block\_dim[i] = get\_elem\_at<int>(data, \textcolor{stringliteral}{"{}uint32"{}}, i * 4);}
\DoxyCodeLine{503 }
\DoxyCodeLine{504     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x = 0; x < block\_dim.x; ++x)}
\DoxyCodeLine{505         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y = 0; y < block\_dim.y; ++y)}
\DoxyCodeLine{506             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} z = 0; z < block\_dim.z; ++z)}
\DoxyCodeLine{507                 dest.SetVoxel(}
\DoxyCodeLine{508                     x + offset.x, y + offset.y, z + offset.z,}
\DoxyCodeLine{509                     get\_elem\_at<T>(data, voxel\_type, \{x, y, z\}, block\_dim));}
\DoxyCodeLine{510 \}}
\DoxyCodeLine{511 }
\DoxyCodeLine{512 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{513 \textcolor{keywordtype}{void} write\_data(\textcolor{keyword}{const} i3d::Image3d<T>\& src,}
\DoxyCodeLine{514                 i3d::Vector3d<int> offset,}
\DoxyCodeLine{515                 std::span<char> data,}
\DoxyCodeLine{516                 \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{517                 i3d::Vector3d<int> block\_size) \{}
\DoxyCodeLine{518     set\_elem\_at(data, \textcolor{stringliteral}{"{}uint32"{}}, 0, block\_size.x);}
\DoxyCodeLine{519     set\_elem\_at(data, \textcolor{stringliteral}{"{}uint32"{}}, 4, block\_size.y);}
\DoxyCodeLine{520     set\_elem\_at(data, \textcolor{stringliteral}{"{}uint32"{}}, 8, block\_size.z);}
\DoxyCodeLine{521 }
\DoxyCodeLine{522     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x = 0; x < block\_size.x; ++x)}
\DoxyCodeLine{523         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y = 0; y < block\_size.y; ++y)}
\DoxyCodeLine{524             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} z = 0; z < block\_size.z; ++z)}
\DoxyCodeLine{525                 set\_elem\_at(}
\DoxyCodeLine{526                     data, voxel\_type, \{x, y, z\}, block\_size,}
\DoxyCodeLine{527                     src.GetVoxel(x + offset.x, y + offset.y, z + offset.z));}
\DoxyCodeLine{528 \}}
\DoxyCodeLine{529 \} \textcolor{comment}{// namespace data\_manip}}
\DoxyCodeLine{530 }
\DoxyCodeLine{531 \textcolor{keyword}{namespace }log \{}
\DoxyCodeLine{532 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{void} \_log(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{533                        \textcolor{keyword}{const} std::string\& type,}
\DoxyCodeLine{534                        \textcolor{keyword}{const} std::source\_location\& location) \{}
\DoxyCodeLine{535     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_LOG\_)}
\DoxyCodeLine{536         \textcolor{keywordflow}{return};}
\DoxyCodeLine{537 }
\DoxyCodeLine{538     std::cout << fmt::format(\textcolor{stringliteral}{"{}[\{\}] \{\} at row \{\}:\(\backslash\)n\{\} \(\backslash\)n\(\backslash\)n"{}}, type,}
\DoxyCodeLine{539                              location.function\_name(), location.line(), msg);}
\DoxyCodeLine{540     \textcolor{keywordflow}{if} (type.find(\textcolor{stringliteral}{"{}ERROR"{}}) != std::string::npos)}
\DoxyCodeLine{541         std::cout << std::flush;}
\DoxyCodeLine{542 \}}
\DoxyCodeLine{543 }
\DoxyCodeLine{544 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{void} info(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{545                        \textcolor{keyword}{const} std::source\_location\&}
\DoxyCodeLine{546                            location \textcolor{comment}{/* = std::source\_location::current() */}) \{}
\DoxyCodeLine{547     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_INFO\_)}
\DoxyCodeLine{548         \textcolor{keywordflow}{return};}
\DoxyCodeLine{549     \_log(msg, \textcolor{stringliteral}{"{}INFO"{}}, location);}
\DoxyCodeLine{550 \}}
\DoxyCodeLine{551 }
\DoxyCodeLine{552 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{void}}
\DoxyCodeLine{553 warning(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{554         \textcolor{keyword}{const} std::source\_location\&}
\DoxyCodeLine{555             location \textcolor{comment}{/* = std::source\_location::current() */}) \{}
\DoxyCodeLine{556     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_WARNING\_)}
\DoxyCodeLine{557         \textcolor{keywordflow}{return};}
\DoxyCodeLine{558     \_log(msg, \textcolor{stringliteral}{"{}WARNING"{}}, location);}
\DoxyCodeLine{559 \}}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{void} error(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{562                         \textcolor{keyword}{const} std::source\_location\&}
\DoxyCodeLine{563                             location \textcolor{comment}{/* = std::source\_location::current() */}) \{}
\DoxyCodeLine{564     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_ERROR\_)}
\DoxyCodeLine{565         \textcolor{keywordflow}{return};}
\DoxyCodeLine{566     \_log(msg, \textcolor{stringliteral}{"{}ERROR"{}}, location);}
\DoxyCodeLine{567 \}}
\DoxyCodeLine{568 \} \textcolor{comment}{// namespace log}}
\DoxyCodeLine{569 }
\DoxyCodeLine{570 \textcolor{keyword}{namespace }props\_parser \{}
\DoxyCodeLine{571 }
\DoxyCodeLine{572 \textcolor{keyword}{template} <cnpts::Basic T>}
\DoxyCodeLine{573 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{574     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{575         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} was not found"{}}, name));}
\DoxyCodeLine{576         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{577     \}}
\DoxyCodeLine{578     \textcolor{keywordflow}{return} root-\/>getValue<T>(name);}
\DoxyCodeLine{579 \}}
\DoxyCodeLine{580 }
\DoxyCodeLine{581 \textcolor{keyword}{template} <cnpts::Vector3d T>}
\DoxyCodeLine{582 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{583     \textcolor{keyword}{using} V = \textcolor{keyword}{decltype}(T\{\}.x);}
\DoxyCodeLine{584     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{585         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} were not found"{}}, name));}
\DoxyCodeLine{586         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{587     \}}
\DoxyCodeLine{588 }
\DoxyCodeLine{589     Array::Ptr values = root-\/>getArray(name);}
\DoxyCodeLine{590     \textcolor{keywordflow}{if} (values-\/>size() != 3) \{}
\DoxyCodeLine{591         log::warning(\textcolor{stringliteral}{"{}Incorrect number of dimensions"{}});}
\DoxyCodeLine{592         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{593     \}}
\DoxyCodeLine{594 }
\DoxyCodeLine{595     T out;}
\DoxyCodeLine{596     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < 3; ++i)}
\DoxyCodeLine{597         out[i] = values-\/>getElement<V>(i);}
\DoxyCodeLine{598 }
\DoxyCodeLine{599     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{600 \}}
\DoxyCodeLine{601 }
\DoxyCodeLine{602 \textcolor{keyword}{template} <cnpts::Vector T>}
\DoxyCodeLine{603 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{604     \textcolor{keyword}{using} V = \textcolor{keyword}{typename} T::value\_type;}
\DoxyCodeLine{605     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{606         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} were not found"{}}, name));}
\DoxyCodeLine{607         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{608     \}}
\DoxyCodeLine{609 }
\DoxyCodeLine{610     Array::Ptr values = root-\/>getArray(name);}
\DoxyCodeLine{611     std::size\_t count = values-\/>size();}
\DoxyCodeLine{612 }
\DoxyCodeLine{613     T out(count);}
\DoxyCodeLine{614     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < count; ++i)}
\DoxyCodeLine{615         out[i] = values-\/>getElement<V>(i);}
\DoxyCodeLine{616 }
\DoxyCodeLine{617     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{618 \}}
\DoxyCodeLine{619 }
\DoxyCodeLine{620 \textcolor{keyword}{template} <cnpts::ResolutionUnit T>}
\DoxyCodeLine{621 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{622     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{623         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} was not found"{}}, name));}
\DoxyCodeLine{624         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{625     \}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627     Object::Ptr res\_ptr = root-\/>getObject(name);}
\DoxyCodeLine{628     ResolutionUnit res;}
\DoxyCodeLine{629 }
\DoxyCodeLine{630     \textcolor{keywordflow}{if} (res\_ptr-\/>has(\textcolor{stringliteral}{"{}value"{}})) \{}
\DoxyCodeLine{631         res.value = res\_ptr-\/>getValue<\textcolor{keywordtype}{double}>(\textcolor{stringliteral}{"{}value"{}});}
\DoxyCodeLine{632     \}}
\DoxyCodeLine{633 }
\DoxyCodeLine{634     \textcolor{keywordflow}{if} (res\_ptr-\/>has(\textcolor{stringliteral}{"{}unit"{}})) \{}
\DoxyCodeLine{635         res.unit = res\_ptr-\/>getValue<std::string>(\textcolor{stringliteral}{"{}unit"{}});}
\DoxyCodeLine{636     \}}
\DoxyCodeLine{637 }
\DoxyCodeLine{638     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{639 \}}
\DoxyCodeLine{640 }
\DoxyCodeLine{641 \textcolor{keyword}{template} <cnpts::Optional T>}
\DoxyCodeLine{642 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{643     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{644         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} were not found"{}}, name));}
\DoxyCodeLine{645         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{646     \}}
\DoxyCodeLine{647 }
\DoxyCodeLine{648     \textcolor{keywordflow}{if} (root-\/>isNull(name))}
\DoxyCodeLine{649         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{650 }
\DoxyCodeLine{651     T out;}
\DoxyCodeLine{652     out = get\_elem<typename T::value\_type>(root, name);}
\DoxyCodeLine{653     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{654 \}}
\DoxyCodeLine{655 }
\DoxyCodeLine{656 \textcolor{comment}{/* inline */} std::vector<std::map<std::string, i3d::Vector3d<int>>>}
\DoxyCodeLine{657 get\_resolution\_levels(Object::Ptr root) \{}
\DoxyCodeLine{658     std::string name = \textcolor{stringliteral}{"{}resolutionLevels"{}};}
\DoxyCodeLine{659 }
\DoxyCodeLine{660     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{661         log::warning(\textcolor{stringliteral}{"{}resolutionLevels were not found"{}});}
\DoxyCodeLine{662         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{663     \}}
\DoxyCodeLine{664 }
\DoxyCodeLine{665     std::vector<std::map<std::string, i3d::Vector3d<int>>> out;}
\DoxyCodeLine{666 }
\DoxyCodeLine{667     Array::Ptr array = root-\/>getArray(name);}
\DoxyCodeLine{668     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < array-\/>size(); ++i) \{}
\DoxyCodeLine{669         std::map<std::string, i3d::Vector3d<int>> map;}
\DoxyCodeLine{670         Object::Ptr map\_ptr = array-\/>getObject(i);}
\DoxyCodeLine{671 }
\DoxyCodeLine{672         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& name : map\_ptr-\/>getNames()) \{}
\DoxyCodeLine{673             map[name] = get\_elem<i3d::Vector3d<int>>(map\_ptr, name);}
\DoxyCodeLine{674         \}}
\DoxyCodeLine{675 }
\DoxyCodeLine{676         out.push\_back(map);}
\DoxyCodeLine{677     \}}
\DoxyCodeLine{678 }
\DoxyCodeLine{679     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{680 \}}
\DoxyCodeLine{681 }
\DoxyCodeLine{682 \} \textcolor{comment}{// namespace props\_parser}}
\DoxyCodeLine{683 }
\DoxyCodeLine{684 \textcolor{keyword}{namespace }requests \{}
\DoxyCodeLine{685 \textcolor{comment}{/* inline */} std::string session\_url\_request(\textcolor{keyword}{const} std::string\& ds\_url,}
\DoxyCodeLine{686                                              i3d::Vector3d<int> resolution,}
\DoxyCodeLine{687                                              \textcolor{keyword}{const} std::string\& version) \{}
\DoxyCodeLine{688 }
\DoxyCodeLine{689     log::info(}
\DoxyCodeLine{690         fmt::format(\textcolor{stringliteral}{"{}Obtaining session url for resolution: \{\}, version: \{\}"{}},}
\DoxyCodeLine{691                     to\_string(resolution), version));}
\DoxyCodeLine{692     std::string req\_url =}
\DoxyCodeLine{693         fmt::format(\textcolor{stringliteral}{"{}\{\}/\{\}/\{\}/\{\}/\{\}/read-\/write"{}}, ds\_url, resolution.x,}
\DoxyCodeLine{694                     resolution.y, resolution.z, version);}
\DoxyCodeLine{695 }
\DoxyCodeLine{696     \textcolor{keyword}{auto} [\_, response] = make\_request(req\_url);}
\DoxyCodeLine{697 }
\DoxyCodeLine{698     \textcolor{keywordtype}{int} res\_code = response.getStatus();}
\DoxyCodeLine{699     \textcolor{keywordflow}{if} (res\_code != 307)}
\DoxyCodeLine{700         log::warning(fmt::format(}
\DoxyCodeLine{701             \textcolor{stringliteral}{"{}Request ended with status: \{\}, redirection may be incorrect"{}},}
\DoxyCodeLine{702             res\_code));}
\DoxyCodeLine{703 }
\DoxyCodeLine{704     \textcolor{keywordflow}{return} response.get(\textcolor{stringliteral}{"{}Location"{}});}
\DoxyCodeLine{705 \}}
\DoxyCodeLine{706 }
\DoxyCodeLine{707 \textcolor{comment}{/* inline */} std::pair<std::vector<char>, Poco::Net::HTTPResponse>}
\DoxyCodeLine{708 make\_request(\textcolor{keyword}{const} std::string\& url,}
\DoxyCodeLine{709              \textcolor{keyword}{const} std::string\& type \textcolor{comment}{/*  = Poco::Net::HTTPRequest::HTTP\_GET */},}
\DoxyCodeLine{710              \textcolor{keyword}{const} std::vector<char>\& data \textcolor{comment}{/*  = \{\} */},}
\DoxyCodeLine{711              \textcolor{keyword}{const} std::map<std::string, std::string>\& headers \textcolor{comment}{/* = \{\} */}) \{}
\DoxyCodeLine{712     Poco::URI uri(url);}
\DoxyCodeLine{713     std::string path(uri.getPathAndQuery());}
\DoxyCodeLine{714 }
\DoxyCodeLine{715     Poco::Net::HTTPClientSession session(uri.getHost(), uri.getPort());}
\DoxyCodeLine{716 }
\DoxyCodeLine{717     Poco::Net::HTTPRequest request(type, path,}
\DoxyCodeLine{718                                    Poco::Net::HTTPMessage::HTTP\_1\_1);}
\DoxyCodeLine{719 }
\DoxyCodeLine{720     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& [key, value] : headers)}
\DoxyCodeLine{721         request.set(key, value);}
\DoxyCodeLine{722 }
\DoxyCodeLine{723     request.setContentLength(data.size());}
\DoxyCodeLine{724 }
\DoxyCodeLine{725     log::info(fmt::format(\textcolor{stringliteral}{"{}Sending \{\} request to url: \{\}"{}}, type, url));}
\DoxyCodeLine{726     std::ostream\& os = session.sendRequest(request);}
\DoxyCodeLine{727     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} ch : data)}
\DoxyCodeLine{728         os << ch;}
\DoxyCodeLine{729 }
\DoxyCodeLine{730     Poco::Net::HTTPResponse response;}
\DoxyCodeLine{731     std::istream\& rs = session.receiveResponse(response);}
\DoxyCodeLine{732 }
\DoxyCodeLine{733     std::vector<char> out\{std::istreambuf\_iterator<char>(rs),}
\DoxyCodeLine{734                           std::istreambuf\_iterator<char>()\};}
\DoxyCodeLine{735 }
\DoxyCodeLine{736     log::info(fmt::format(}
\DoxyCodeLine{737         \textcolor{stringliteral}{"{}Fetched response with status: \{\}, reason: \{\}, content size: \{\}"{}},}
\DoxyCodeLine{738         response.getStatus(), response.getReason(), out.size()));}
\DoxyCodeLine{739 }
\DoxyCodeLine{740     \textcolor{keywordflow}{return} \{out, response\};}
\DoxyCodeLine{741 \}}
\DoxyCodeLine{742 }
\DoxyCodeLine{743 \} \textcolor{comment}{// namespace requests}}
\DoxyCodeLine{744 \} \textcolor{comment}{// namespace details}}
\DoxyCodeLine{745 \} \textcolor{comment}{// namespace datastore}}

\end{DoxyCode}

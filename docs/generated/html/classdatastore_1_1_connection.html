<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HPC-datastore-cpp: datastore::Connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HPC-datastore-cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>datastore</b></li><li class="navelem"><a class="el" href="classdatastore_1_1_connection.html">Connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdatastore_1_1_connection-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">datastore::Connection Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Representation of connection to dataset.  
 <a href="classdatastore_1_1_connection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hpc__ds__api_8hpp_source.html">hpc_ds_api.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a765b984fa9b01dd1157698bf2aa913c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#a765b984fa9b01dd1157698bf2aa913c9">Connection</a> (std::string ip, int port, std::string uuid)</td></tr>
<tr class="memdesc:a765b984fa9b01dd1157698bf2aa913c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classdatastore_1_1_connection.html" title="Representation of connection to dataset.">Connection</a> object.  <a href="classdatastore_1_1_connection.html#a765b984fa9b01dd1157698bf2aa913c9">More...</a><br /></td></tr>
<tr class="separator:a765b984fa9b01dd1157698bf2aa913c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de526df0d0278f44891a31c2f3ea5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatastore_1_1_image_view.html">ImageView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#a8de526df0d0278f44891a31c2f3ea5c3">get_view</a> (int channel, int timepoint, int angle, i3d::Vector3d&lt; int &gt; resolution, const std::string &amp;version) const</td></tr>
<tr class="memdesc:a8de526df0d0278f44891a31c2f3ea5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classdatastore_1_1_image_view.html" title="Representation of connection to specific image.">ImageView</a> of specified image.  <a href="classdatastore_1_1_connection.html#a8de526df0d0278f44891a31c2f3ea5c3">More...</a><br /></td></tr>
<tr class="separator:a8de526df0d0278f44891a31c2f3ea5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e13e60e924dd1d0596b7f6c68a3644b"><td class="memTemplParams" colspan="2">template&lt;cnpts::Scalar T&gt; </td></tr>
<tr class="memitem:a0e13e60e924dd1d0596b7f6c68a3644b"><td class="memTemplItemLeft" align="right" valign="top">i3d::Image3d&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#a0e13e60e924dd1d0596b7f6c68a3644b">read_block</a> (i3d::Vector3d&lt; int &gt; coord, int channel, int timepoint, int angle, i3d::Vector3d&lt; int &gt; resolution, const std::string &amp;version) const</td></tr>
<tr class="memdesc:a0e13e60e924dd1d0596b7f6c68a3644b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one block from server to image.  <a href="classdatastore_1_1_connection.html#a0e13e60e924dd1d0596b7f6c68a3644b">More...</a><br /></td></tr>
<tr class="separator:a0e13e60e924dd1d0596b7f6c68a3644b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4725dcebff426e4f2e1c5127ce86d50b"><td class="memTemplParams" colspan="2">template&lt;cnpts::Scalar T&gt; </td></tr>
<tr class="memitem:a4725dcebff426e4f2e1c5127ce86d50b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#a4725dcebff426e4f2e1c5127ce86d50b">read_block</a> (i3d::Vector3d&lt; int &gt; coord, i3d::Image3d&lt; T &gt; &amp;dest, i3d::Vector3d&lt; int &gt; dest_offset, int channel, int timepoint, int angle, i3d::Vector3d&lt; int &gt; resolution, const std::string &amp;version) const</td></tr>
<tr class="memdesc:a4725dcebff426e4f2e1c5127ce86d50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one block from server to image.  <a href="classdatastore_1_1_connection.html#a4725dcebff426e4f2e1c5127ce86d50b">More...</a><br /></td></tr>
<tr class="separator:a4725dcebff426e4f2e1c5127ce86d50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1153887794c75d8fd0eab237d6ada649"><td class="memTemplParams" colspan="2">template&lt;cnpts::Scalar T&gt; </td></tr>
<tr class="memitem:a1153887794c75d8fd0eab237d6ada649"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; i3d::Image3d&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#a1153887794c75d8fd0eab237d6ada649">read_blocks</a> (const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;coords, int channel, int timepoint, int angle, i3d::Vector3d&lt; int &gt; resolution, const std::string &amp;version) const</td></tr>
<tr class="memdesc:a1153887794c75d8fd0eab237d6ada649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read blocks from server and return them.  <a href="classdatastore_1_1_connection.html#a1153887794c75d8fd0eab237d6ada649">More...</a><br /></td></tr>
<tr class="separator:a1153887794c75d8fd0eab237d6ada649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c64ce0f5444c53d95c5e1632927a74c"><td class="memTemplParams" colspan="2">template&lt;cnpts::Scalar T&gt; </td></tr>
<tr class="memitem:a9c64ce0f5444c53d95c5e1632927a74c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#a9c64ce0f5444c53d95c5e1632927a74c">read_blocks</a> (const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;coords, i3d::Image3d&lt; T &gt; &amp;dest, const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;dest_offsets, int channel, int timepoint, int angle, i3d::Vector3d&lt; int &gt; resolution, const std::string &amp;version) const</td></tr>
<tr class="memdesc:a9c64ce0f5444c53d95c5e1632927a74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read blocks from server and saves them into prealocated image.  <a href="classdatastore_1_1_connection.html#a9c64ce0f5444c53d95c5e1632927a74c">More...</a><br /></td></tr>
<tr class="separator:a9c64ce0f5444c53d95c5e1632927a74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b911a6c8445fcd8026eb694fca132e3"><td class="memTemplParams" colspan="2">template&lt;cnpts::Scalar T&gt; </td></tr>
<tr class="memitem:a7b911a6c8445fcd8026eb694fca132e3"><td class="memTemplItemLeft" align="right" valign="top">i3d::Image3d&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#a7b911a6c8445fcd8026eb694fca132e3">read_image</a> (int channel, int timepoint, int angle, i3d::Vector3d&lt; int &gt; resolution, const std::string &amp;version) const</td></tr>
<tr class="memdesc:a7b911a6c8445fcd8026eb694fca132e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read full image.  <a href="classdatastore_1_1_connection.html#a7b911a6c8445fcd8026eb694fca132e3">More...</a><br /></td></tr>
<tr class="separator:a7b911a6c8445fcd8026eb694fca132e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcde47294bc421fe7571abfc2b238c73"><td class="memTemplParams" colspan="2">template&lt;cnpts::Scalar T&gt; </td></tr>
<tr class="memitem:abcde47294bc421fe7571abfc2b238c73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#abcde47294bc421fe7571abfc2b238c73">write_block</a> (const i3d::Image3d&lt; T &gt; &amp;src, i3d::Vector3d&lt; int &gt; coord, i3d::Vector3d&lt; int &gt; src_offset, int channel, int timepoint, int angle, i3d::Vector3d&lt; int &gt; resolution, const std::string &amp;version) const</td></tr>
<tr class="memdesc:abcde47294bc421fe7571abfc2b238c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write block to server.  <a href="classdatastore_1_1_connection.html#abcde47294bc421fe7571abfc2b238c73">More...</a><br /></td></tr>
<tr class="separator:abcde47294bc421fe7571abfc2b238c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5cf7bc0d746951b98a2f627ac9d781"><td class="memTemplParams" colspan="2">template&lt;cnpts::Scalar T&gt; </td></tr>
<tr class="memitem:adc5cf7bc0d746951b98a2f627ac9d781"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#adc5cf7bc0d746951b98a2f627ac9d781">write_blocks</a> (const i3d::Image3d&lt; T &gt; &amp;src, const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;coords, const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;src_offsets, int channel, int timepoint, int angle, i3d::Vector3d&lt; int &gt; resolution, const std::string &amp;version) const</td></tr>
<tr class="memdesc:adc5cf7bc0d746951b98a2f627ac9d781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write blocks to server.  <a href="classdatastore_1_1_connection.html#adc5cf7bc0d746951b98a2f627ac9d781">More...</a><br /></td></tr>
<tr class="separator:adc5cf7bc0d746951b98a2f627ac9d781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11d17adf5cf1fd8ff52ba777da38f93"><td class="memTemplParams" colspan="2">template&lt;cnpts::Scalar T&gt; </td></tr>
<tr class="memitem:ab11d17adf5cf1fd8ff52ba777da38f93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatastore_1_1_connection.html#ab11d17adf5cf1fd8ff52ba777da38f93">write_image</a> (const i3d::Image3d&lt; T &gt; &amp;img, int channel, int timepoint, int angle, i3d::Vector3d&lt; int &gt; resolution, const std::string &amp;version) const</td></tr>
<tr class="memdesc:ab11d17adf5cf1fd8ff52ba777da38f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write image to server.  <a href="classdatastore_1_1_connection.html#ab11d17adf5cf1fd8ff52ba777da38f93">More...</a><br /></td></tr>
<tr class="separator:ab11d17adf5cf1fd8ff52ba777da38f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Representation of connection to dataset. </p>
<p >Class representing connection to specific dataset on the server. It provides basic methods for read/write operations necessary to tranfser images (in the dataset) from/to server. This class does not cache or precollect any data, so the first HTTP request will be send only when corresponding function is called.</p>
<p >All of the methods accepts arguments that uniquely identifies requested image. At the backend, this class tranfsers commands into <a class="el" href="classdatastore_1_1_image_view.html" title="Representation of connection to specific image.">ImageView</a> objects. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a765b984fa9b01dd1157698bf2aa913c9" name="a765b984fa9b01dd1157698bf2aa913c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765b984fa9b01dd1157698bf2aa913c9">&#9670;&nbsp;</a></span>Connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">datastore::Connection::Connection </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>uuid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classdatastore_1_1_connection.html" title="Representation of connection to dataset.">Connection</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>IP address of server (<a href="http://">http://</a> at the beginning is not necessary) </td></tr>
    <tr><td class="paramname">port</td><td>Port, where the server is listening for requests </td></tr>
    <tr><td class="paramname">uuid</td><td>Unique identifier of dataset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8de526df0d0278f44891a31c2f3ea5c3" name="a8de526df0d0278f44891a31c2f3ea5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de526df0d0278f44891a31c2f3ea5c3">&#9670;&nbsp;</a></span>get_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatastore_1_1_image_view.html">ImageView</a> datastore::Connection::get_view </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classdatastore_1_1_image_view.html" title="Representation of connection to specific image.">ImageView</a> of specified image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel, at which the image is located </td></tr>
    <tr><td class="paramname">timepoint</td><td>Timepoint, at which the image is located </td></tr>
    <tr><td class="paramname">angle</td><td>Angle, at which the image is located </td></tr>
    <tr><td class="paramname">resolution</td><td>Resolution, at which the image is located </td></tr>
    <tr><td class="paramname">version</td><td>Version, at which the image is located (integer identifier or "latest") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classdatastore_1_1_image_view.html" title="Representation of connection to specific image.">ImageView</a> </dd></dl>

</div>
</div>
<a id="a4725dcebff426e4f2e1c5127ce86d50b" name="a4725dcebff426e4f2e1c5127ce86d50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4725dcebff426e4f2e1c5127ce86d50b">&#9670;&nbsp;</a></span>read_block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cnpts::Scalar T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool datastore::Connection::read_block </td>
          <td>(</td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Image3d&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>dest_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one block from server to image. </p>
<p >Reads one block of image located at &lt;coord&gt; and saves it to &lt;dest&gt; with offset &lt;dest_offset&gt;.</p>
<p >If in DEBUG, function will check wheter given coordinate corresponds to valid block as well as wheter the block fits into the image (taking offset into account).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar used as underlying type for image representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>Block coordinate </td></tr>
    <tr><td class="paramname">dest</td><td>Image to write data to </td></tr>
    <tr><td class="paramname">dest_offset</td><td>Offset by which the corresponding write should be moved </td></tr>
    <tr><td class="paramname">channel</td><td>Channel, at which the image is located </td></tr>
    <tr><td class="paramname">timepoint</td><td>Timepoint, at which the image is located </td></tr>
    <tr><td class="paramname">angle</td><td>Angle, at which the image is located </td></tr>
    <tr><td class="paramname">resolution</td><td>Resolution, at which the image is located </td></tr>
    <tr><td class="paramname">version</td><td>Version, at which the image is located (integer identifier or "latest") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true At read success </dd>
<dd>
false At read failiure </dd></dl>

</div>
</div>
<a id="a0e13e60e924dd1d0596b7f6c68a3644b" name="a0e13e60e924dd1d0596b7f6c68a3644b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e13e60e924dd1d0596b7f6c68a3644b">&#9670;&nbsp;</a></span>read_block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cnpts::Scalar T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">i3d::Image3d&lt; T &gt; datastore::Connection::read_block </td>
          <td>(</td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one block from server to image. </p>
<p >Reads one block of image located at &lt;coord&gt; and saves it to &lt;dest&gt; with offset &lt;dest_offset&gt;.</p>
<p >If in DEBUG, function will check wheter given coordinate corresponds to valid block as well as wheter the block fits into the image (taking offset into account).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar used as underlying type for image representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>Block coordinate </td></tr>
    <tr><td class="paramname">channel</td><td>Channel, at which the image is located </td></tr>
    <tr><td class="paramname">timepoint</td><td>Timepoint, at which the image is located </td></tr>
    <tr><td class="paramname">angle</td><td>Angle, at which the image is located </td></tr>
    <tr><td class="paramname">resolution</td><td>Resolution, at which the image is located </td></tr>
    <tr><td class="paramname">version</td><td>Version, at which the image is located (integer identifier or "latest") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Image containing selected block </dd></dl>

</div>
</div>
<a id="a9c64ce0f5444c53d95c5e1632927a74c" name="a9c64ce0f5444c53d95c5e1632927a74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c64ce0f5444c53d95c5e1632927a74c">&#9670;&nbsp;</a></span>read_blocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cnpts::Scalar T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool datastore::Connection::read_blocks </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Image3d&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read blocks from server and saves them into prealocated image. </p>
<p >Read blocks specified in &lt;coords&gt; and saves them into locations given in &lt;offsets&gt;.</p>
<p >If in DEBUG, the function checks if coordinates given in &lt;coords&gt; points to a valid blocks, as well as wheter the offsets specified for each block are within image boundaries.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar used as underlying type for image representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>Block coordinates </td></tr>
    <tr><td class="paramname">dest</td><td>Prealocated destination image </td></tr>
    <tr><td class="paramname">dest_offsets</td><td>Offsets at wich the corresponding blocks should be saved </td></tr>
    <tr><td class="paramname">channel</td><td>Channel, at which the image is located </td></tr>
    <tr><td class="paramname">timepoint</td><td>Timepoint, at which the image is located </td></tr>
    <tr><td class="paramname">angle</td><td>Angle, at which the image is located </td></tr>
    <tr><td class="paramname">resolution</td><td>Resolution, at which the image is located </td></tr>
    <tr><td class="paramname">version</td><td>Version, at which the image is located (integer identifier or "latest") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true At read success </dd>
<dd>
false At read failure </dd></dl>

</div>
</div>
<a id="a1153887794c75d8fd0eab237d6ada649" name="a1153887794c75d8fd0eab237d6ada649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1153887794c75d8fd0eab237d6ada649">&#9670;&nbsp;</a></span>read_blocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cnpts::Scalar T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; i3d::Image3d&lt; T &gt; &gt; datastore::Connection::read_blocks </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read blocks from server and return them. </p>
<p >Reads blocks specified in &lt;coords&gt; and returns them. Corresponding sizes are collected from server and calculated specificaly for each block.</p>
<p >This function is not optimized, meaning that for each coord in &lt;coord&gt;, one HTTP request will be sent out to the server. This can heavily slow down speed of the application as communication via network is not cheap. If you do not have specific needs,most of the time it will be faster to collect blocks into prealocated image (second overload of read_blocks), however it will eat more RAM.</p>
<p >If in DEBUG, the fucntion checks if coordinates given in &lt;coords&gt; points to a valid blocks.</p>
<p >As there is no (meaningfull) way for C++ to choose correct underlying type in runtime, make sure to specify correct template type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar used as underlying type for image representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>Block coordinates </td></tr>
    <tr><td class="paramname">channel</td><td>Channel, at which the image is located </td></tr>
    <tr><td class="paramname">timepoint</td><td>Timepoint, at which the image is located </td></tr>
    <tr><td class="paramname">angle</td><td>Angle, at which the image is located </td></tr>
    <tr><td class="paramname">resolution</td><td>Resolution, at which the image is located </td></tr>
    <tr><td class="paramname">version</td><td>Version, at which the image is located (integer identifier or "latest") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of fetched blocks (the order is the same as given in &lt;coords&gt;) </dd></dl>

</div>
</div>
<a id="a7b911a6c8445fcd8026eb694fca132e3" name="a7b911a6c8445fcd8026eb694fca132e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b911a6c8445fcd8026eb694fca132e3">&#9670;&nbsp;</a></span>read_image()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cnpts::Scalar T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">i3d::Image3d&lt; T &gt; datastore::Connection::read_image </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read full image. </p>
<p >Read full image from the server and return it. The information about dimensions are fetched from the server.</p>
<p >As there is no (meaningfull) way for C++ to choose correct underlying type in runtime, make sure to specify correct template type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar used as underlying type for image representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel, at which the image is located </td></tr>
    <tr><td class="paramname">timepoint</td><td>Timepoint, at which the image is located </td></tr>
    <tr><td class="paramname">angle</td><td>Angle, at which the image is located </td></tr>
    <tr><td class="paramname">resolution</td><td>Resolution, at which the image is located </td></tr>
    <tr><td class="paramname">version</td><td>Version, at which the image is located (integer identifier or "latest") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>i3d::Image3d&lt;T&gt; etched image </dd></dl>

</div>
</div>
<a id="abcde47294bc421fe7571abfc2b238c73" name="abcde47294bc421fe7571abfc2b238c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcde47294bc421fe7571abfc2b238c73">&#9670;&nbsp;</a></span>write_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cnpts::Scalar T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool datastore::Connection::write_block </td>
          <td>(</td>
          <td class="paramtype">const i3d::Image3d&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>src_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write block to server. </p>
<p >Write block from source image to server. The information about dimensions are fetched from the server.</p>
<p >If in DEBUG, the function checks if coordinate given in &lt;coord&gt; points to a valid block, as well as wheter the offset specified for block is within image boundaries.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar used as underlying type for image representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source image to collect block from </td></tr>
    <tr><td class="paramname">coord</td><td>Block coordinates </td></tr>
    <tr><td class="paramname">src_offset</td><td>Offset of given block in source image </td></tr>
    <tr><td class="paramname">channel</td><td>Channel, at which the image is located </td></tr>
    <tr><td class="paramname">timepoint</td><td>Timepoint, at which the image is located </td></tr>
    <tr><td class="paramname">angle</td><td>Angle, at which the image is located </td></tr>
    <tr><td class="paramname">resolution</td><td>Resolution, at which the image is located </td></tr>
    <tr><td class="paramname">version</td><td>Version, at which the image is located (integer identifier or "latest") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true At write success </dd>
<dd>
false At write failiure </dd></dl>

</div>
</div>
<a id="adc5cf7bc0d746951b98a2f627ac9d781" name="adc5cf7bc0d746951b98a2f627ac9d781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5cf7bc0d746951b98a2f627ac9d781">&#9670;&nbsp;</a></span>write_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cnpts::Scalar T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool datastore::Connection::write_blocks </td>
          <td>(</td>
          <td class="paramtype">const i3d::Image3d&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; i3d::Vector3d&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write blocks to server. </p>
<p >Write blocks from source image to server. The information about dimensions are fetched from the server.</p>
<p >If in DEBUG, the function checks if coordinates given in &lt;coords&gt; points to a valid block, as well as wheter the offsets specified for each block is within image boundaries.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar used as underlying type for image representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source image to collect blocks from </td></tr>
    <tr><td class="paramname">coords</td><td>Vector of block coordinates </td></tr>
    <tr><td class="paramname">src_offsets</td><td>Offsets of corresponding blocks in source image </td></tr>
    <tr><td class="paramname">channel</td><td>Channel, at which the image is located </td></tr>
    <tr><td class="paramname">timepoint</td><td>Timepoint, at which the image is located </td></tr>
    <tr><td class="paramname">angle</td><td>Angle, at which the image is located </td></tr>
    <tr><td class="paramname">resolution</td><td>Resolution, at which the image is located </td></tr>
    <tr><td class="paramname">version</td><td>Version, at which the image is located (integer identifier or "latest") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true At write success </dd>
<dd>
false At write failiure </dd></dl>

</div>
</div>
<a id="ab11d17adf5cf1fd8ff52ba777da38f93" name="ab11d17adf5cf1fd8ff52ba777da38f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11d17adf5cf1fd8ff52ba777da38f93">&#9670;&nbsp;</a></span>write_image()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cnpts::Scalar T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool datastore::Connection::write_image </td>
          <td>(</td>
          <td class="paramtype">const i3d::Image3d&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i3d::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write image to server. </p>
<p >Write full image to server.</p>
<p >It is recommended to make sure that the dimension of the source image is the same as the dimension of image at server side.</p>
<p >Mostly, given smaller source image will emit error and fail to upload. Given larger source image will result in cropping.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar used as underlying type for image representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Source image </td></tr>
    <tr><td class="paramname">channel</td><td>Channel, at which the image is located </td></tr>
    <tr><td class="paramname">timepoint</td><td>Timepoint, at which the image is located </td></tr>
    <tr><td class="paramname">angle</td><td>Angle, at which the image is located </td></tr>
    <tr><td class="paramname">resolution</td><td>Resolution, at which the image is located </td></tr>
    <tr><td class="paramname">version</td><td>Version, at which the image is located (integer identifier or "latest") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true true At write success </dd>
<dd>
false At write failiure </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/somik/CBIA/hpc-datastore-cpp/src/<a class="el" href="hpc__ds__api_8hpp_source.html">hpc_ds_api.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>

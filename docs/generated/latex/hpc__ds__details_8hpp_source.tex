\hypertarget{hpc__ds__details_8hpp_source}{}\doxysection{hpc\+\_\+ds\+\_\+details.\+hpp}
\label{hpc__ds__details_8hpp_source}\index{/home/somik/CBIA/hpc-\/datastore-\/cpp/src/hpc\_ds\_details.hpp@{/home/somik/CBIA/hpc-\/datastore-\/cpp/src/hpc\_ds\_details.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#include "{}hpc\_ds\_structs.hpp"{}}}
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <Poco/JSON/Object.h>}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#include <Poco/JSON/Parser.h>}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <Poco/Net/HTTPClientSession.h>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <Poco/Net/HTTPMessage.h>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <Poco/Net/HTTPRequest.h>}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include <Poco/Net/HTTPResponse.h>}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include <Poco/URI.h>}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include <i3d/image3d.h>}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <i3d/vector3d.h>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <optional>}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <source\_location>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <span>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{17 \textcolor{comment}{/* ==================== DETAILS HEADERS ============================ */}}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{keyword}{namespace }ds \{}
\DoxyCodeLine{20 \textcolor{keyword}{namespace }details \{}
\DoxyCodeLine{21 \textcolor{comment}{/* Definition of compile settings */}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{preprocessor}{\#ifdef DATASTORE\_NDEBUG}}
\DoxyCodeLine{24 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_DEBUG\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#ifdef NDEBUG}}
\DoxyCodeLine{27 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_DEBUG\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{29 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_DEBUG\_ = \textcolor{keyword}{true};}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{preprocessor}{\#ifdef DATASTORE\_NLOG}}
\DoxyCodeLine{34 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_LOG\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{36 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_LOG\_ = \_DEBUG\_;}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{preprocessor}{\#ifdef DATASTORE\_NINFO}}
\DoxyCodeLine{40 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_INFO\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{42 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_INFO\_ = \_LOG\_;}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{preprocessor}{\#ifdef DATASTORE\_NWARNING}}
\DoxyCodeLine{46 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_WARNING\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{48 \textcolor{keyword}{constexpr} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_WARNING\_ = \_LOG\_;}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{50 }
\DoxyCodeLine{59 \textcolor{keyword}{inline} std::string}
\DoxyCodeLine{60 get\_dataset\_url(\textcolor{keyword}{const} std::string\& ip, \textcolor{keywordtype}{int} port, \textcolor{keyword}{const} std::string\& uuid);}
\DoxyCodeLine{61 }
\DoxyCodeLine{68 \textcolor{keyword}{inline} DatasetProperties get\_dataset\_properties(\textcolor{keyword}{const} std::string\& dataset\_url);}
\DoxyCodeLine{69 }
\DoxyCodeLine{81 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} check\_block\_coords(\textcolor{keyword}{const} std::vector<i3d::Vector3d<int>>\& coords,}
\DoxyCodeLine{82                                i3d::Vector3d<int> img\_dim,}
\DoxyCodeLine{83                                i3d::Vector3d<int> block\_dim);}
\DoxyCodeLine{84 }
\DoxyCodeLine{85 \textcolor{keyword}{inline} std::vector<i3d::Vector3d<int>>}
\DoxyCodeLine{86 get\_intercepted\_blocks(i3d::Vector3d<int> start\_point,}
\DoxyCodeLine{87                        i3d::Vector3d<int> end\_point,}
\DoxyCodeLine{88                        i3d::Vector3d<int> img\_dim,}
\DoxyCodeLine{89                        i3d::Vector3d<int> block\_dim);}
\DoxyCodeLine{90 }
\DoxyCodeLine{91 \textcolor{keyword}{namespace }data\_manip \{}
\DoxyCodeLine{92 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} get\_block\_data\_size(i3d::Vector3d<int> block\_size,}
\DoxyCodeLine{93                                \textcolor{keyword}{const} std::string\& voxel\_type);}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 \textcolor{keyword}{inline} i3d::Vector3d<int> get\_block\_size(i3d::Vector3d<int> coord,}
\DoxyCodeLine{96                                          i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{97                                          i3d::Vector3d<int> img\_dim);}
\DoxyCodeLine{98 }
\DoxyCodeLine{99 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} get\_linear\_index(i3d::Vector3d<int> coord,}
\DoxyCodeLine{100                             i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{101                             \textcolor{keyword}{const} std::string\& voxel\_type);}
\DoxyCodeLine{102 }
\DoxyCodeLine{103 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{104 T get\_elem\_at(std::span<const char> data,}
\DoxyCodeLine{105               \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{106               \textcolor{keywordtype}{int} index);}
\DoxyCodeLine{107 }
\DoxyCodeLine{108 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{109 T get\_elem\_at(std::span<const char> data,}
\DoxyCodeLine{110               \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{111               i3d::Vector3d<int> coord,}
\DoxyCodeLine{112               i3d::Vector3d<int> block\_dim);}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{115 \textcolor{keywordtype}{void} set\_elem\_at(std::span<char> data,}
\DoxyCodeLine{116                  \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{117                  \textcolor{keywordtype}{int} index,}
\DoxyCodeLine{118                  T elem);}
\DoxyCodeLine{119 }
\DoxyCodeLine{120 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{121 \textcolor{keywordtype}{void} set\_elem\_at(std::span<char> data,}
\DoxyCodeLine{122                  \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{123                  i3d::Vector3d<int> coord,}
\DoxyCodeLine{124                  i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{125                  T elem);}
\DoxyCodeLine{126 }
\DoxyCodeLine{136 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{137 \textcolor{keywordtype}{void} read\_data(std::span<const char> data,}
\DoxyCodeLine{138                \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{139                i3d::Image3d<T>\& dest,}
\DoxyCodeLine{140                i3d::Vector3d<int> offset);}
\DoxyCodeLine{141 }
\DoxyCodeLine{152 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{153 \textcolor{keywordtype}{void} write\_data(\textcolor{keyword}{const} i3d::Image3d<T>\& src,}
\DoxyCodeLine{154                 i3d::Vector3d<int> offset,}
\DoxyCodeLine{155                 std::span<char> data,}
\DoxyCodeLine{156                 \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{157                 i3d::Vector3d<int> block\_size);}
\DoxyCodeLine{158 \} \textcolor{comment}{// namespace data\_manip}}
\DoxyCodeLine{159 }
\DoxyCodeLine{160 \textcolor{keyword}{namespace }log \{}
\DoxyCodeLine{161 }
\DoxyCodeLine{169 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \_log(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{170                  \textcolor{keyword}{const} std::string\& type,}
\DoxyCodeLine{171                  \textcolor{keyword}{const} std::source\_location\& location);}
\DoxyCodeLine{172 }
\DoxyCodeLine{179 \textcolor{keyword}{inline} \textcolor{keywordtype}{void}}
\DoxyCodeLine{180 info(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{181      \textcolor{keyword}{const} std::source\_location\& location = std::source\_location::current());}
\DoxyCodeLine{182 }
\DoxyCodeLine{189 \textcolor{keyword}{inline} \textcolor{keywordtype}{void}}
\DoxyCodeLine{190 warning(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{191         \textcolor{keyword}{const} std::source\_location\& location = std::source\_location::current());}
\DoxyCodeLine{192 }
\DoxyCodeLine{193 \} \textcolor{comment}{// namespace log}}
\DoxyCodeLine{194 \textcolor{comment}{/* Helpers to parse Dataset Properties from JSON */}}
\DoxyCodeLine{195 \textcolor{keyword}{namespace }props\_parser \{}
\DoxyCodeLine{196 \textcolor{keyword}{using namespace }Poco::JSON;}
\DoxyCodeLine{197 }
\DoxyCodeLine{198 \textcolor{keyword}{template} <cnpts::Basic T>}
\DoxyCodeLine{199 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{200 }
\DoxyCodeLine{201 \textcolor{keyword}{template} <cnpts::Vector3d T>}
\DoxyCodeLine{202 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{203 }
\DoxyCodeLine{204 \textcolor{keyword}{template} <cnpts::Vector T>}
\DoxyCodeLine{205 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 \textcolor{keyword}{template} <cnpts::ResolutionUnit T>}
\DoxyCodeLine{208 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{209 }
\DoxyCodeLine{210 \textcolor{keyword}{template} <cnpts::Optional T>}
\DoxyCodeLine{211 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name);}
\DoxyCodeLine{212 }
\DoxyCodeLine{213 \textcolor{keyword}{inline} std::vector<std::map<std::string, i3d::Vector3d<int>>>}
\DoxyCodeLine{214 get\_resolution\_levels(Object::Ptr root);}
\DoxyCodeLine{215 }
\DoxyCodeLine{216 \} \textcolor{comment}{// namespace props\_parser}}
\DoxyCodeLine{217 }
\DoxyCodeLine{218 \textcolor{comment}{/* Helpers providing requests functionality */}}
\DoxyCodeLine{219 \textcolor{keyword}{namespace }requests \{}
\DoxyCodeLine{220 \textcolor{keyword}{inline} std::string session\_url\_request(\textcolor{keyword}{const} std::string\& ds\_url,}
\DoxyCodeLine{221                                        i3d::Vector3d<int> resolution,}
\DoxyCodeLine{222                                        \textcolor{keyword}{const} std::string\& version);}
\DoxyCodeLine{223 }
\DoxyCodeLine{224 \textcolor{keyword}{inline} std::pair<std::vector<char>, Poco::Net::HTTPResponse>}
\DoxyCodeLine{225 make\_request(\textcolor{keyword}{const} std::string\& url,}
\DoxyCodeLine{226              \textcolor{keyword}{const} std::string\& type = Poco::Net::HTTPRequest::HTTP\_GET,}
\DoxyCodeLine{227              \textcolor{keyword}{const} std::vector<char>\& data = \{\},}
\DoxyCodeLine{228              \textcolor{keyword}{const} std::map<std::string, std::string>\& headers = \{\});}
\DoxyCodeLine{229 \} \textcolor{comment}{// namespace requests}}
\DoxyCodeLine{230 \} \textcolor{comment}{// namespace details}}
\DoxyCodeLine{231 \} \textcolor{comment}{// namespace ds}}
\DoxyCodeLine{232 }
\DoxyCodeLine{233 \textcolor{comment}{/* ================= IMPLEMENTATION FOLLOWS ======================== */}}
\DoxyCodeLine{234 \textcolor{keyword}{namespace }ds \{}
\DoxyCodeLine{235 \textcolor{keyword}{namespace }details \{}
\DoxyCodeLine{236 }
\DoxyCodeLine{237 \textcolor{comment}{/* inline */} std::string}
\DoxyCodeLine{238 get\_dataset\_url(\textcolor{keyword}{const} std::string\& ip, \textcolor{keywordtype}{int} port, \textcolor{keyword}{const} std::string\& uuid) \{}
\DoxyCodeLine{239     std::string out;}
\DoxyCodeLine{240     \textcolor{keywordflow}{if} (!ip.starts\_with(\textcolor{stringliteral}{"{}http://"{}}))}
\DoxyCodeLine{241         out = \textcolor{stringliteral}{"{}https://"{}};}
\DoxyCodeLine{242     \textcolor{keywordflow}{return} out + fmt::format(\textcolor{stringliteral}{"{}\{\}:\{\}/datasets/\{\}"{}}, ip, port, uuid);}
\DoxyCodeLine{243 \}}
\DoxyCodeLine{244 }
\DoxyCodeLine{245 \textcolor{keyword}{inline} DatasetProperties}
\DoxyCodeLine{246 get\_dataset\_properties(\textcolor{keyword}{const} std::string\& dataset\_url) \{}
\DoxyCodeLine{247     \textcolor{keyword}{using namespace }Poco::JSON;}
\DoxyCodeLine{248 }
\DoxyCodeLine{249     \textcolor{comment}{/* Fetch JSON from server */}}
\DoxyCodeLine{250     \textcolor{keyword}{auto} [data, response] = requests::make\_request(dataset\_url);}
\DoxyCodeLine{251     std::string json\_str(data.begin(), data.end());}
\DoxyCodeLine{252 }
\DoxyCodeLine{253     \textcolor{keywordtype}{int} res\_code = response.getStatus();}
\DoxyCodeLine{254     \textcolor{keywordflow}{if} (res\_code != 200)}
\DoxyCodeLine{255         log::warning(fmt::format(}
\DoxyCodeLine{256             \textcolor{stringliteral}{"{}Request ended with code: \{\}. json may not be valid"{}}, res\_code));}
\DoxyCodeLine{257 }
\DoxyCodeLine{258     log::info(\textcolor{stringliteral}{"{}Parsing dataset properties from JSON string"{}});}
\DoxyCodeLine{259     Parser parser;}
\DoxyCodeLine{260     Poco::Dynamic::Var result = parser.parse(json\_str);}
\DoxyCodeLine{261 }
\DoxyCodeLine{262     DatasetProperties props;}
\DoxyCodeLine{263     \textcolor{keyword}{auto} root = result.extract<Object::Ptr>();}
\DoxyCodeLine{264 }
\DoxyCodeLine{265     \textcolor{keyword}{using namespace }props\_parser;}
\DoxyCodeLine{266 }
\DoxyCodeLine{267     \textcolor{comment}{/* Parse elements from JSON */}}
\DoxyCodeLine{268 }
\DoxyCodeLine{269     props.uuid = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}uuid"{}});}
\DoxyCodeLine{270     props.voxel\_type = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}voxelType"{}});}
\DoxyCodeLine{271     props.dimensions = get\_elem<i3d::Vector3d<int>>(root, \textcolor{stringliteral}{"{}dimensions"{}});}
\DoxyCodeLine{272     props.channels = get\_elem<int>(root, \textcolor{stringliteral}{"{}channels"{}});}
\DoxyCodeLine{273     props.angles = get\_elem<int>(root, \textcolor{stringliteral}{"{}angles"{}});}
\DoxyCodeLine{274     props.transformations =}
\DoxyCodeLine{275         get\_elem<std::optional<std::string>>(root, \textcolor{stringliteral}{"{}transformations"{}});}
\DoxyCodeLine{276     props.voxel\_unit = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}voxelUnit"{}});}
\DoxyCodeLine{277     props.voxel\_resolution =}
\DoxyCodeLine{278         get\_elem<std::optional<i3d::Vector3d<double>>>(root, \textcolor{stringliteral}{"{}voxelResolution"{}});}
\DoxyCodeLine{279     props.timepoint\_resolution =}
\DoxyCodeLine{280         get\_elem<std::optional<ResolutionUnit>>(root, \textcolor{stringliteral}{"{}timepointResolution"{}});}
\DoxyCodeLine{281     props.channel\_resolution =}
\DoxyCodeLine{282         get\_elem<std::optional<ResolutionUnit>>(root, \textcolor{stringliteral}{"{}channelResolution"{}});}
\DoxyCodeLine{283     props.angle\_resolution =}
\DoxyCodeLine{284         get\_elem<std::optional<ResolutionUnit>>(root, \textcolor{stringliteral}{"{}angleResolution"{}});}
\DoxyCodeLine{285     props.compression = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}compression"{}});}
\DoxyCodeLine{286     props.resolution\_levels = get\_resolution\_levels(root);}
\DoxyCodeLine{287     props.versions = get\_elem<std::vector<int>>(root, \textcolor{stringliteral}{"{}versions"{}});}
\DoxyCodeLine{288     props.label = get\_elem<std::string>(root, \textcolor{stringliteral}{"{}label"{}});}
\DoxyCodeLine{289     props.view\_registrations =}
\DoxyCodeLine{290         get\_elem<std::optional<std::string>>(root, \textcolor{stringliteral}{"{}viewRegistrations"{}});}
\DoxyCodeLine{291     props.timepoint\_ids = get\_elem<std::vector<int>>(root, \textcolor{stringliteral}{"{}timepointIds"{}});}
\DoxyCodeLine{292 }
\DoxyCodeLine{293     log::info(\textcolor{stringliteral}{"{}Parsing has finished"{}});}
\DoxyCodeLine{294     \textcolor{keywordflow}{return} props;}
\DoxyCodeLine{295 \}}
\DoxyCodeLine{296 }
\DoxyCodeLine{297 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{bool}}
\DoxyCodeLine{298 check\_block\_coords(\textcolor{keyword}{const} std::vector<i3d::Vector3d<int>>\& coords,}
\DoxyCodeLine{299                    i3d::Vector3d<int> img\_dim,}
\DoxyCodeLine{300                    i3d::Vector3d<int> block\_dim) \{}
\DoxyCodeLine{301     \textcolor{comment}{/* Act as NOOP if not in debug */}}
\DoxyCodeLine{302     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_DEBUG\_)}
\DoxyCodeLine{303         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{304 }
\DoxyCodeLine{305     log::info(\textcolor{stringliteral}{"{}Checking validity of given block coordinates"{}});}
\DoxyCodeLine{306 }
\DoxyCodeLine{307     \textcolor{keywordflow}{for} (i3d::Vector3d<int> coord : coords)}
\DoxyCodeLine{308         \textcolor{keywordflow}{if} (data\_manip::get\_block\_size(coord, block\_dim, img\_dim) ==}
\DoxyCodeLine{309             i3d::Vector3d(0, 0, 0)) \{}
\DoxyCodeLine{310             log::warning(fmt::format(}
\DoxyCodeLine{311                 \textcolor{stringliteral}{"{}Block coordinate \{\} is out of valid range"{}}, to\_string(coord)));}
\DoxyCodeLine{312 }
\DoxyCodeLine{313             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{314         \}}
\DoxyCodeLine{315     log::info(\textcolor{stringliteral}{"{}Check successfullly finished"{}});}
\DoxyCodeLine{316     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{317 \}}
\DoxyCodeLine{318 }
\DoxyCodeLine{319 \textcolor{comment}{/* inline */} std::vector<i3d::Vector3d<int>>}
\DoxyCodeLine{320 get\_intercepted\_blocks(i3d::Vector3d<int> start\_point,}
\DoxyCodeLine{321                        i3d::Vector3d<int> end\_point,}
\DoxyCodeLine{322                        i3d::Vector3d<int> img\_dim,}
\DoxyCodeLine{323                        i3d::Vector3d<int> block\_dim) \{}
\DoxyCodeLine{324     assert(start\_point < end\_point);}
\DoxyCodeLine{325 }
\DoxyCodeLine{326     i3d::Vector3d<int> block\_count = (img\_dim + block\_dim -\/ 1) / block\_dim;}
\DoxyCodeLine{327     std::vector<i3d::Vector3d<int>> out;}
\DoxyCodeLine{328 }
\DoxyCodeLine{329     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x = 0; x < block\_count.x; ++x)}
\DoxyCodeLine{330         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y = 0; y < block\_count.y; ++y)}
\DoxyCodeLine{331             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} z = 0; z < block\_count.z; ++z) \{}
\DoxyCodeLine{332                 i3d::Vector3d<int> coord = \{x, y, z\};}
\DoxyCodeLine{333                 \textcolor{keywordflow}{if} (start\_point < (coord + 1) * block\_dim \&\&}
\DoxyCodeLine{334                     coord * block\_dim < end\_point)}
\DoxyCodeLine{335                     out.push\_back(coord);}
\DoxyCodeLine{336             \}}
\DoxyCodeLine{337 }
\DoxyCodeLine{338     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{339 \}}
\DoxyCodeLine{340 }
\DoxyCodeLine{341 \textcolor{keyword}{namespace }data\_manip \{}
\DoxyCodeLine{342 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{int} get\_block\_data\_size(i3d::Vector3d<int> block\_size,}
\DoxyCodeLine{343                                      \textcolor{keyword}{const} std::string\& voxel\_type) \{}
\DoxyCodeLine{344 }
\DoxyCodeLine{345     \textcolor{keywordtype}{int} elem\_size = type\_byte\_size.at(voxel\_type);}
\DoxyCodeLine{346     \textcolor{keywordflow}{return} block\_size.x * block\_size.y * block\_size.z * elem\_size + 12;}
\DoxyCodeLine{347 \}}
\DoxyCodeLine{348 }
\DoxyCodeLine{349 \textcolor{comment}{/* inline */} i3d::Vector3d<int> get\_block\_size(i3d::Vector3d<int> coord,}
\DoxyCodeLine{350                                                i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{351                                                i3d::Vector3d<int> img\_dim) \{}
\DoxyCodeLine{352     i3d::Vector3d<int> start = (coord * block\_dim);}
\DoxyCodeLine{353     i3d::Vector3d<int> end = (coord + 1) * block\_dim;}
\DoxyCodeLine{354 }
\DoxyCodeLine{355     i3d::Vector3d<int> out;}
\DoxyCodeLine{356     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; ++i) \{}
\DoxyCodeLine{357         out[i] =}
\DoxyCodeLine{358             std::max(0, std::min(img\_dim[i], end[i]) -\/ std::max(start[i], 0));}
\DoxyCodeLine{359     \}}
\DoxyCodeLine{360     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{361 \}}
\DoxyCodeLine{362 }
\DoxyCodeLine{363 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{int} get\_linear\_index(i3d::Vector3d<int> coord,}
\DoxyCodeLine{364                                   i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{365                                   \textcolor{keyword}{const} std::string\& voxel\_type) \{}
\DoxyCodeLine{366     \textcolor{keywordtype}{int} elem\_size = type\_byte\_size.at(voxel\_type);}
\DoxyCodeLine{367 }
\DoxyCodeLine{368     \textcolor{keywordflow}{return} 12 +                                   \textcolor{comment}{// header\_offset}}
\DoxyCodeLine{369            (coord.z * block\_dim.x * block\_dim.y + \textcolor{comment}{// Main axis}}
\DoxyCodeLine{370             coord.y * block\_dim.x +               \textcolor{comment}{// secondary axis}}
\DoxyCodeLine{371             coord.x) *                            \textcolor{comment}{// last axis}}
\DoxyCodeLine{372                elem\_size;                         \textcolor{comment}{// byte size}}
\DoxyCodeLine{373 \}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{376 T get\_elem\_at(std::span<const char> data,}
\DoxyCodeLine{377               \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{378               \textcolor{keywordtype}{int} index) \{}
\DoxyCodeLine{379     \textcolor{keywordtype}{int} elem\_size = type\_byte\_size.at(voxel\_type);}
\DoxyCodeLine{380 }
\DoxyCodeLine{381     std::array<char, \textcolor{keyword}{sizeof}(T)> buffer\{\};}
\DoxyCodeLine{382     std::copy\_n(data.begin() + index,      \textcolor{comment}{// source start}}
\DoxyCodeLine{383                 elem\_size,                 \textcolor{comment}{// count}}
\DoxyCodeLine{384                 buffer.end() -\/ elem\_size); \textcolor{comment}{// dest start}}
\DoxyCodeLine{385 }
\DoxyCodeLine{386     std::ranges::reverse(buffer);}
\DoxyCodeLine{387 }
\DoxyCodeLine{388     \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}(\&buffer[0]);}
\DoxyCodeLine{389 \}}
\DoxyCodeLine{390 }
\DoxyCodeLine{391 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{392 T get\_elem\_at(std::span<const char> data,}
\DoxyCodeLine{393               \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{394               i3d::Vector3d<int> coord,}
\DoxyCodeLine{395               i3d::Vector3d<int> block\_dim) \{}
\DoxyCodeLine{396 }
\DoxyCodeLine{397     \textcolor{keywordtype}{int} index = get\_linear\_index(coord, block\_dim, voxel\_type);}
\DoxyCodeLine{398     \textcolor{keywordflow}{return} get\_elem\_at<T>(data, voxel\_type, index);}
\DoxyCodeLine{399 \}}
\DoxyCodeLine{400 }
\DoxyCodeLine{401 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{402 \textcolor{keywordtype}{void} set\_elem\_at(std::span<char> data,}
\DoxyCodeLine{403                  \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{404                  \textcolor{keywordtype}{int} index,}
\DoxyCodeLine{405                  T elem) \{}
\DoxyCodeLine{406     \textcolor{keywordtype}{int} elem\_size = type\_byte\_size.at(voxel\_type);}
\DoxyCodeLine{407 }
\DoxyCodeLine{408     \textcolor{keyword}{auto} buffer = *\textcolor{keyword}{reinterpret\_cast<}std::array<\textcolor{keywordtype}{char}, sizeof(T)\textcolor{keyword}{>}*>(\&elem);}
\DoxyCodeLine{409     std::ranges::reverse(buffer);}
\DoxyCodeLine{410 }
\DoxyCodeLine{411     std::copy\_n(buffer.end() -\/ elem\_size, \textcolor{comment}{// source start}}
\DoxyCodeLine{412                 elem\_size,                \textcolor{comment}{// count}}
\DoxyCodeLine{413                 data.begin() + index);    \textcolor{comment}{// dest start}}
\DoxyCodeLine{414 \}}
\DoxyCodeLine{415 }
\DoxyCodeLine{416 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{417 \textcolor{keywordtype}{void} set\_elem\_at(std::span<char> data,}
\DoxyCodeLine{418                  \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{419                  i3d::Vector3d<int> coord,}
\DoxyCodeLine{420                  i3d::Vector3d<int> block\_dim,}
\DoxyCodeLine{421                  T elem) \{}
\DoxyCodeLine{422     \textcolor{keywordtype}{int} index = get\_linear\_index(coord, block\_dim, voxel\_type);}
\DoxyCodeLine{423     set\_elem\_at(data, voxel\_type, index, elem);}
\DoxyCodeLine{424 \}}
\DoxyCodeLine{425 }
\DoxyCodeLine{426 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{427 \textcolor{keywordtype}{void} read\_data(std::span<const char> data,}
\DoxyCodeLine{428                \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{429                i3d::Image3d<T>\& dest,}
\DoxyCodeLine{430                i3d::Vector3d<int> offset) \{}
\DoxyCodeLine{431     i3d::Vector3d<int> block\_dim;}
\DoxyCodeLine{432     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; ++i)}
\DoxyCodeLine{433         block\_dim[i] = get\_elem\_at<int>(data, \textcolor{stringliteral}{"{}uint32"{}}, i * 4);}
\DoxyCodeLine{434 }
\DoxyCodeLine{435     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x = 0; x < block\_dim.x; ++x)}
\DoxyCodeLine{436         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y = 0; y < block\_dim.y; ++y)}
\DoxyCodeLine{437             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} z = 0; z < block\_dim.z; ++z)}
\DoxyCodeLine{438                 dest.SetVoxel(}
\DoxyCodeLine{439                     x + offset.x, y + offset.y, z + offset.z,}
\DoxyCodeLine{440                     get\_elem\_at<T>(data, voxel\_type, \{x, y, z\}, block\_dim));}
\DoxyCodeLine{441 \}}
\DoxyCodeLine{442 }
\DoxyCodeLine{443 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{444 \textcolor{keywordtype}{void} write\_data(\textcolor{keyword}{const} i3d::Image3d<T>\& src,}
\DoxyCodeLine{445                 i3d::Vector3d<int> offset,}
\DoxyCodeLine{446                 std::span<char> data,}
\DoxyCodeLine{447                 \textcolor{keyword}{const} std::string\& voxel\_type,}
\DoxyCodeLine{448                 i3d::Vector3d<int> block\_size) \{}
\DoxyCodeLine{449     set\_elem\_at(data, \textcolor{stringliteral}{"{}uint32"{}}, 0, block\_size.x);}
\DoxyCodeLine{450     set\_elem\_at(data, \textcolor{stringliteral}{"{}uint32"{}}, 4, block\_size.y);}
\DoxyCodeLine{451     set\_elem\_at(data, \textcolor{stringliteral}{"{}uint32"{}}, 8, block\_size.z);}
\DoxyCodeLine{452 }
\DoxyCodeLine{453     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x = 0; x < block\_size.x; ++x)}
\DoxyCodeLine{454         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y = 0; y < block\_size.y; ++y)}
\DoxyCodeLine{455             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} z = 0; z < block\_size.z; ++z)}
\DoxyCodeLine{456                 set\_elem\_at(}
\DoxyCodeLine{457                     data, voxel\_type, \{x, y, z\}, block\_size,}
\DoxyCodeLine{458                     src.GetVoxel(x + offset.x, y + offset.y, z + offset.z));}
\DoxyCodeLine{459 \}}
\DoxyCodeLine{460 \} \textcolor{comment}{// namespace data\_manip}}
\DoxyCodeLine{461 }
\DoxyCodeLine{462 \textcolor{keyword}{namespace }log \{}
\DoxyCodeLine{463 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{void} \_log(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{464                        \textcolor{keyword}{const} std::string\& type,}
\DoxyCodeLine{465                        \textcolor{keyword}{const} std::source\_location\& location) \{}
\DoxyCodeLine{466     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_LOG\_)}
\DoxyCodeLine{467         \textcolor{keywordflow}{return};}
\DoxyCodeLine{468 }
\DoxyCodeLine{469     std::cout << fmt::format(\textcolor{stringliteral}{"{}[\{\}] \{\} at row \{\}:\(\backslash\)n\{\} \(\backslash\)n\(\backslash\)n"{}}, type,}
\DoxyCodeLine{470                              location.function\_name(), location.line(), msg);}
\DoxyCodeLine{471 \}}
\DoxyCodeLine{472 }
\DoxyCodeLine{473 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{void} info(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{474                        \textcolor{keyword}{const} std::source\_location\&}
\DoxyCodeLine{475                            location \textcolor{comment}{/* = std::source\_location::current() */}) \{}
\DoxyCodeLine{476     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_INFO\_)}
\DoxyCodeLine{477         \textcolor{keywordflow}{return};}
\DoxyCodeLine{478     \_log(msg, \textcolor{stringliteral}{"{}INFO"{}}, location);}
\DoxyCodeLine{479 \}}
\DoxyCodeLine{480 }
\DoxyCodeLine{481 \textcolor{comment}{/* inline */} \textcolor{keywordtype}{void}}
\DoxyCodeLine{482 warning(\textcolor{keyword}{const} std::string\& msg,}
\DoxyCodeLine{483         \textcolor{keyword}{const} std::source\_location\&}
\DoxyCodeLine{484             location \textcolor{comment}{/* = std::source\_location::current() */}) \{}
\DoxyCodeLine{485     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!\_WARNING\_)}
\DoxyCodeLine{486         \textcolor{keywordflow}{return};}
\DoxyCodeLine{487     \_log(msg, \textcolor{stringliteral}{"{}WARNING"{}}, location);}
\DoxyCodeLine{488 \}}
\DoxyCodeLine{489 \} \textcolor{comment}{// namespace log}}
\DoxyCodeLine{490 }
\DoxyCodeLine{491 \textcolor{keyword}{namespace }props\_parser \{}
\DoxyCodeLine{492 }
\DoxyCodeLine{493 \textcolor{keyword}{template} <cnpts::Basic T>}
\DoxyCodeLine{494 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{495     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{496         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} was not found"{}}, name));}
\DoxyCodeLine{497         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{498     \}}
\DoxyCodeLine{499     \textcolor{keywordflow}{return} root-\/>getValue<T>(name);}
\DoxyCodeLine{500 \}}
\DoxyCodeLine{501 }
\DoxyCodeLine{502 \textcolor{keyword}{template} <cnpts::Vector3d T>}
\DoxyCodeLine{503 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{504     \textcolor{keyword}{using} V = \textcolor{keyword}{decltype}(T\{\}.x);}
\DoxyCodeLine{505     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{506         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} were not found"{}}, name));}
\DoxyCodeLine{507         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{508     \}}
\DoxyCodeLine{509 }
\DoxyCodeLine{510     Array::Ptr values = root-\/>getArray(name);}
\DoxyCodeLine{511     \textcolor{keywordflow}{if} (values-\/>size() != 3) \{}
\DoxyCodeLine{512         log::warning(\textcolor{stringliteral}{"{}Incorrect number of dimensions"{}});}
\DoxyCodeLine{513         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{514     \}}
\DoxyCodeLine{515 }
\DoxyCodeLine{516     T out;}
\DoxyCodeLine{517     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < 3; ++i)}
\DoxyCodeLine{518         out[i] = values-\/>getElement<V>(i);}
\DoxyCodeLine{519 }
\DoxyCodeLine{520     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{521 \}}
\DoxyCodeLine{522 }
\DoxyCodeLine{523 \textcolor{keyword}{template} <cnpts::Vector T>}
\DoxyCodeLine{524 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{525     \textcolor{keyword}{using} V = \textcolor{keyword}{typename} T::value\_type;}
\DoxyCodeLine{526     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{527         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} were not found"{}}, name));}
\DoxyCodeLine{528         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{529     \}}
\DoxyCodeLine{530 }
\DoxyCodeLine{531     Array::Ptr values = root-\/>getArray(name);}
\DoxyCodeLine{532     std::size\_t count = values-\/>size();}
\DoxyCodeLine{533 }
\DoxyCodeLine{534     T out(count);}
\DoxyCodeLine{535     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < count; ++i)}
\DoxyCodeLine{536         out[i] = values-\/>getElement<V>(i);}
\DoxyCodeLine{537 }
\DoxyCodeLine{538     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{539 \}}
\DoxyCodeLine{540 }
\DoxyCodeLine{541 \textcolor{keyword}{template} <cnpts::ResolutionUnit T>}
\DoxyCodeLine{542 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{543     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{544         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} was not found"{}}, name));}
\DoxyCodeLine{545         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{546     \}}
\DoxyCodeLine{547 }
\DoxyCodeLine{548     Object::Ptr res\_ptr = root-\/>getObject(name);}
\DoxyCodeLine{549     ResolutionUnit res;}
\DoxyCodeLine{550 }
\DoxyCodeLine{551     \textcolor{keywordflow}{if} (res\_ptr-\/>has(\textcolor{stringliteral}{"{}value"{}})) \{}
\DoxyCodeLine{552         res.value = res\_ptr-\/>getValue<\textcolor{keywordtype}{double}>(\textcolor{stringliteral}{"{}value"{}});}
\DoxyCodeLine{553     \}}
\DoxyCodeLine{554 }
\DoxyCodeLine{555     \textcolor{keywordflow}{if} (res\_ptr-\/>has(\textcolor{stringliteral}{"{}unit"{}})) \{}
\DoxyCodeLine{556         res.unit = res\_ptr-\/>getValue<std::string>(\textcolor{stringliteral}{"{}unit"{}});}
\DoxyCodeLine{557     \}}
\DoxyCodeLine{558 }
\DoxyCodeLine{559     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{560 \}}
\DoxyCodeLine{561 }
\DoxyCodeLine{562 \textcolor{keyword}{template} <cnpts::Optional T>}
\DoxyCodeLine{563 T get\_elem(Object::Ptr root, \textcolor{keyword}{const} std::string\& name) \{}
\DoxyCodeLine{564     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{565         log::warning(fmt::format(\textcolor{stringliteral}{"{}\{\} were not found"{}}, name));}
\DoxyCodeLine{566         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{567     \}}
\DoxyCodeLine{568 }
\DoxyCodeLine{569     \textcolor{keywordflow}{if} (root-\/>isNull(name))}
\DoxyCodeLine{570         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{571 }
\DoxyCodeLine{572     T out;}
\DoxyCodeLine{573     out = get\_elem<typename T::value\_type>(root, name);}
\DoxyCodeLine{574     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{575 \}}
\DoxyCodeLine{576 }
\DoxyCodeLine{577 \textcolor{comment}{/* inline */} std::vector<std::map<std::string, i3d::Vector3d<int>>>}
\DoxyCodeLine{578 get\_resolution\_levels(Object::Ptr root) \{}
\DoxyCodeLine{579     std::string name = \textcolor{stringliteral}{"{}resolutionLevels"{}};}
\DoxyCodeLine{580 }
\DoxyCodeLine{581     \textcolor{keywordflow}{if} (!root-\/>has(name)) \{}
\DoxyCodeLine{582         log::warning(\textcolor{stringliteral}{"{}resolutionLevels were not found"{}});}
\DoxyCodeLine{583         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{584     \}}
\DoxyCodeLine{585 }
\DoxyCodeLine{586     std::vector<std::map<std::string, i3d::Vector3d<int>>> out;}
\DoxyCodeLine{587 }
\DoxyCodeLine{588     Array::Ptr array = root-\/>getArray(name);}
\DoxyCodeLine{589     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < array-\/>size(); ++i) \{}
\DoxyCodeLine{590         std::map<std::string, i3d::Vector3d<int>> map;}
\DoxyCodeLine{591         Object::Ptr map\_ptr = array-\/>getObject(i);}
\DoxyCodeLine{592 }
\DoxyCodeLine{593         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& name : map\_ptr-\/>getNames()) \{}
\DoxyCodeLine{594             map[name] = get\_elem<i3d::Vector3d<int>>(map\_ptr, name);}
\DoxyCodeLine{595         \}}
\DoxyCodeLine{596 }
\DoxyCodeLine{597         out.push\_back(map);}
\DoxyCodeLine{598     \}}
\DoxyCodeLine{599 }
\DoxyCodeLine{600     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{601 \}}
\DoxyCodeLine{602 }
\DoxyCodeLine{603 \} \textcolor{comment}{// namespace props\_parser}}
\DoxyCodeLine{604 }
\DoxyCodeLine{605 \textcolor{keyword}{namespace }requests \{}
\DoxyCodeLine{606 \textcolor{comment}{/* inline */} std::string session\_url\_request(\textcolor{keyword}{const} std::string\& ds\_url,}
\DoxyCodeLine{607                                              i3d::Vector3d<int> resolution,}
\DoxyCodeLine{608                                              \textcolor{keyword}{const} std::string\& version) \{}
\DoxyCodeLine{609 }
\DoxyCodeLine{610     log::info(}
\DoxyCodeLine{611         fmt::format(\textcolor{stringliteral}{"{}Obtaining session url for resolution: \{\}, version: \{\}"{}},}
\DoxyCodeLine{612                     to\_string(resolution), version));}
\DoxyCodeLine{613     std::string req\_url =}
\DoxyCodeLine{614         fmt::format(\textcolor{stringliteral}{"{}\{\}/\{\}/\{\}/\{\}/\{\}/read-\/write"{}}, ds\_url, resolution.x,}
\DoxyCodeLine{615                     resolution.y, resolution.z, version);}
\DoxyCodeLine{616 }
\DoxyCodeLine{617     \textcolor{keyword}{auto} [\_, response] = make\_request(req\_url);}
\DoxyCodeLine{618 }
\DoxyCodeLine{619     \textcolor{keywordtype}{int} res\_code = response.getStatus();}
\DoxyCodeLine{620     \textcolor{keywordflow}{if} (res\_code != 307)}
\DoxyCodeLine{621         log::warning(fmt::format(}
\DoxyCodeLine{622             \textcolor{stringliteral}{"{}Request ended with status: \{\}, redirection may be incorrect"{}},}
\DoxyCodeLine{623             res\_code));}
\DoxyCodeLine{624 }
\DoxyCodeLine{625     \textcolor{keywordflow}{return} response.get(\textcolor{stringliteral}{"{}Location"{}});}
\DoxyCodeLine{626 \}}
\DoxyCodeLine{627 }
\DoxyCodeLine{628 \textcolor{comment}{/* inline */} std::pair<std::vector<char>, Poco::Net::HTTPResponse>}
\DoxyCodeLine{629 make\_request(\textcolor{keyword}{const} std::string\& url,}
\DoxyCodeLine{630              \textcolor{keyword}{const} std::string\& type \textcolor{comment}{/*  = Poco::Net::HTTPRequest::HTTP\_GET */},}
\DoxyCodeLine{631              \textcolor{keyword}{const} std::vector<char>\& data \textcolor{comment}{/*  = \{\} */},}
\DoxyCodeLine{632              \textcolor{keyword}{const} std::map<std::string, std::string>\& headers \textcolor{comment}{/* = \{\} */}) \{}
\DoxyCodeLine{633     Poco::URI uri(url);}
\DoxyCodeLine{634     std::string path(uri.getPathAndQuery());}
\DoxyCodeLine{635 }
\DoxyCodeLine{636     Poco::Net::HTTPClientSession session(uri.getHost(), uri.getPort());}
\DoxyCodeLine{637 }
\DoxyCodeLine{638     Poco::Net::HTTPRequest request(type, path,}
\DoxyCodeLine{639                                    Poco::Net::HTTPMessage::HTTP\_1\_1);}
\DoxyCodeLine{640 }
\DoxyCodeLine{641     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& [key, value] : headers)}
\DoxyCodeLine{642         request.set(key, value);}
\DoxyCodeLine{643 }
\DoxyCodeLine{644     request.setContentLength(data.size());}
\DoxyCodeLine{645 }
\DoxyCodeLine{646     log::info(fmt::format(\textcolor{stringliteral}{"{}Sending \{\} request to url: \{\}"{}}, type, url));}
\DoxyCodeLine{647     std::ostream\& os = session.sendRequest(request);}
\DoxyCodeLine{648     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} ch : data)}
\DoxyCodeLine{649         os << ch;}
\DoxyCodeLine{650 }
\DoxyCodeLine{651     Poco::Net::HTTPResponse response;}
\DoxyCodeLine{652     std::istream\& rs = session.receiveResponse(response);}
\DoxyCodeLine{653 }
\DoxyCodeLine{654     std::vector<char> out\{std::istreambuf\_iterator<char>(rs),}
\DoxyCodeLine{655                           std::istreambuf\_iterator<char>()\};}
\DoxyCodeLine{656 }
\DoxyCodeLine{657     log::info(fmt::format(}
\DoxyCodeLine{658         \textcolor{stringliteral}{"{}Fetched response with status: \{\}, reason: \{\}, content size: \{\}"{}},}
\DoxyCodeLine{659         response.getStatus(), response.getReason(), out.size()));}
\DoxyCodeLine{660 }
\DoxyCodeLine{661     \textcolor{keywordflow}{return} \{out, response\};}
\DoxyCodeLine{662 \}}
\DoxyCodeLine{663 }
\DoxyCodeLine{664 \} \textcolor{comment}{// namespace requests}}
\DoxyCodeLine{665 \} \textcolor{comment}{// namespace details}}
\DoxyCodeLine{666 \} \textcolor{comment}{// namespace ds}}

\end{DoxyCode}
